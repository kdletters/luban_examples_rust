
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum EExecutor {
    CLIENT = 0,
    SERVER = 1,
}

impl From<i32> for EExecutor {
    fn from(value: i32) -> Self {
        match value {
            0 => EExecutor::CLIENT,
            1 => EExecutor::SERVER,
            _ => panic!("Invalid value for EExecutor:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum EFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}

impl From<i32> for EFinishMode {
    fn from(value: i32) -> Self {
        match value {
            0 => EFinishMode::IMMEDIATE,
            1 => EFinishMode::DELAYED,
            _ => panic!("Invalid value for EFinishMode:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum EFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}

impl From<i32> for EFlowAbortMode {
    fn from(value: i32) -> Self {
        match value {
            0 => EFlowAbortMode::NONE,
            1 => EFlowAbortMode::LOWER_PRIORITY,
            2 => EFlowAbortMode::SELF,
            3 => EFlowAbortMode::BOTH,
            _ => panic!("Invalid value for EFlowAbortMode:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum EKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS1 = 8,
    ENUM1 = 9,
    OBJECT = 10,
}

impl From<i32> for EKeyType {
    fn from(value: i32) -> Self {
        match value {
            1 => EKeyType::BOOL,
            2 => EKeyType::INT,
            3 => EKeyType::FLOAT,
            4 => EKeyType::STRING,
            5 => EKeyType::VECTOR,
            6 => EKeyType::ROTATOR,
            7 => EKeyType::NAME,
            8 => EKeyType::CLASS1,
            9 => EKeyType::ENUM1,
            10 => EKeyType::OBJECT,
            _ => panic!("Invalid value for EKeyType:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum ENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}

impl From<i32> for ENotifyObserverMode {
    fn from(value: i32) -> Self {
        match value {
            0 => ENotifyObserverMode::ON_VALUE_CHANGE,
            1 => ENotifyObserverMode::ON_RESULT_CHANGE,
            _ => panic!("Invalid value for ENotifyObserverMode:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum EOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}

impl From<i32> for EOperator {
    fn from(value: i32) -> Self {
        match value {
            0 => EOperator::IS_EQUAL_TO,
            1 => EOperator::IS_NOT_EQUAL_TO,
            2 => EOperator::IS_LESS_THAN,
            3 => EOperator::IS_LESS_THAN_OR_EQUAL_TO,
            4 => EOperator::IS_GREAT_THAN,
            5 => EOperator::IS_GREAT_THAN_OR_EQUAL_TO,
            6 => EOperator::CONTAINS,
            7 => EOperator::NOT_CONTAINS,
            _ => panic!("Invalid value for EOperator:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct BehaviorTree {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub blackboard_id: String,
    pub blackboard_id_ref: Option<std::sync::Arc<ai::Blackboard>>,
    pub root: ai::ComposeNode,
}

impl BehaviorTree{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<BehaviorTree, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let blackboard_id = buf.read_string();
        let blackboard_id_ref = None;
        let root = ai::ComposeNode::new(&mut buf)?;
        
        Ok(BehaviorTree { id, name, desc, blackboard_id, blackboard_id_ref, root, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.blackboard_id_ref = tables.TbBlackboard.get(&self.blackboard_id);
        self.root.resolve_ref(tables);
    }

    pub const __ID__: i32 = 159552822;
}

#[derive(Debug)]
pub struct Blackboard {
    pub name: String,
    pub desc: String,
    pub parent_name: String,
    pub parent_name_ref: Option<std::sync::Arc<ai::Blackboard>>,
    pub keys: Vec<ai::BlackboardKey>,
}

impl Blackboard{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Blackboard, LubanError> {
        let name = buf.read_string();
        let desc = buf.read_string();
        let parent_name = buf.read_string();
        let parent_name_ref = None;
        let keys = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::BlackboardKey::new(&mut buf)?); } _e0 };
        
        Ok(Blackboard { name, desc, parent_name, parent_name_ref, keys, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.parent_name_ref = tables.TbBlackboard.get(&self.parent_name);
        self.keys.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 1576193005;
}

#[derive(Debug)]
pub struct BlackboardKey {
    pub name: String,
    pub desc: String,
    pub is_static: bool,
    pub key_type: ai::EKeyType,
    pub type_class_name: String,
}

impl BlackboardKey{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<BlackboardKey, LubanError> {
        let name = buf.read_string();
        let desc = buf.read_string();
        let is_static = buf.read_bool();
        let key_type = Into::<ai::EKeyType>::into(buf.read_int());
        let type_class_name = buf.read_string();
        
        Ok(BlackboardKey { name, desc, is_static, key_type, type_class_name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -511559886;
}

#[derive(Debug)]
pub enum KeyData {
    FloatKeyData(std::sync::Arc<ai::FloatKeyData>),
    IntKeyData(std::sync::Arc<ai::IntKeyData>),
    StringKeyData(std::sync::Arc<ai::StringKeyData>),
    BlackboardKeyData(std::sync::Arc<ai::BlackboardKeyData>),
}

impl KeyData {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::FloatKeyData::__ID__ => Ok(Self::FloatKeyData(std::sync::Arc::new(ai::FloatKeyData::new(buf)?))),
            ai::IntKeyData::__ID__ => Ok(Self::IntKeyData(std::sync::Arc::new(ai::IntKeyData::new(buf)?))),
            ai::StringKeyData::__ID__ => Ok(Self::StringKeyData(std::sync::Arc::new(ai::StringKeyData::new(buf)?))),
            ai::BlackboardKeyData::__ID__ => Ok(Self::BlackboardKeyData(std::sync::Arc::new(ai::BlackboardKeyData::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyData:{}", type_id)))
        }
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::FloatKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::FloatKeyData as *mut ai::FloatKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IntKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::IntKeyData as *mut ai::IntKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::StringKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::StringKeyData as *mut ai::StringKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::BlackboardKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::BlackboardKeyData as *mut ai::BlackboardKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct BlackboardKeyData {
    pub value: String,
}

impl BlackboardKeyData{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<BlackboardKeyData, LubanError> {
        let value = buf.read_string();
        
        Ok(BlackboardKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1517269500;
}

#[derive(Debug)]
pub struct FloatKeyData {
    pub value: f32,
}

impl FloatKeyData{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<FloatKeyData, LubanError> {
        let value = buf.read_float();
        
        Ok(FloatKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -719747885;
}

#[derive(Debug)]
pub struct IntKeyData {
    pub value: i32,
}

impl IntKeyData{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<IntKeyData, LubanError> {
        let value = buf.read_int();
        
        Ok(IntKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -342751904;
}

#[derive(Debug)]
pub struct StringKeyData {
    pub value: String,
}

impl StringKeyData{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<StringKeyData, LubanError> {
        let value = buf.read_string();
        
        Ok(StringKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -307888654;
}

#[derive(Debug)]
pub enum KeyQueryOperator {
    IsSet2(std::sync::Arc<ai::IsSet2>),
    IsNotSet(std::sync::Arc<ai::IsNotSet>),
    BinaryOperator(std::sync::Arc<ai::BinaryOperator>),
}

impl KeyQueryOperator {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::IsSet2::__ID__ => Ok(Self::IsSet2(std::sync::Arc::new(ai::IsSet2::new(buf)?))),
            ai::IsNotSet::__ID__ => Ok(Self::IsNotSet(std::sync::Arc::new(ai::IsNotSet::new(buf)?))),
            ai::BinaryOperator::__ID__ => Ok(Self::BinaryOperator(std::sync::Arc::new(ai::BinaryOperator::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyQueryOperator:{}", type_id)))
        }
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::IsSet2(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::IsSet2 as *mut ai::IsSet2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IsNotSet(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::IsNotSet as *mut ai::IsNotSet); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::BinaryOperator(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::BinaryOperator as *mut ai::BinaryOperator); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct BinaryOperator {
    pub oper: ai::EOperator,
    pub data: ai::KeyData,
}

impl BinaryOperator{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<BinaryOperator, LubanError> {
        let oper = Into::<ai::EOperator>::into(buf.read_int());
        let data = ai::KeyData::new(&mut buf)?;
        
        Ok(BinaryOperator { oper, data, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }

    pub const __ID__: i32 = -979891605;
}

#[derive(Debug)]
pub struct IsNotSet {
}

impl IsNotSet{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<IsNotSet, LubanError> {
        
        Ok(IsNotSet { })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 790736255;
}

#[derive(Debug)]
pub struct IsSet2 {
}

impl IsSet2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<IsSet2, LubanError> {
        
        Ok(IsSet2 { })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -843729664;
}

#[derive(Debug)]
pub enum Node {
    UeSetDefaultFocus(std::sync::Arc<ai::UeSetDefaultFocus>),
    ExecuteTimeStatistic(std::sync::Arc<ai::ExecuteTimeStatistic>),
    ChooseTarget(std::sync::Arc<ai::ChooseTarget>),
    KeepFaceTarget(std::sync::Arc<ai::KeepFaceTarget>),
    GetOwnerPlayer(std::sync::Arc<ai::GetOwnerPlayer>),
    UpdateDailyBehaviorProps(std::sync::Arc<ai::UpdateDailyBehaviorProps>),
    UeLoop(std::sync::Arc<ai::UeLoop>),
    UeCooldown(std::sync::Arc<ai::UeCooldown>),
    UeTimeLimit(std::sync::Arc<ai::UeTimeLimit>),
    UeBlackboard(std::sync::Arc<ai::UeBlackboard>),
    UeForceSuccess(std::sync::Arc<ai::UeForceSuccess>),
    IsAtLocation(std::sync::Arc<ai::IsAtLocation>),
    DistanceLessThan(std::sync::Arc<ai::DistanceLessThan>),
    Sequence(std::sync::Arc<ai::Sequence>),
    Selector(std::sync::Arc<ai::Selector>),
    SimpleParallel(std::sync::Arc<ai::SimpleParallel>),
    UeWait(std::sync::Arc<ai::UeWait>),
    UeWaitBlackboardTime(std::sync::Arc<ai::UeWaitBlackboardTime>),
    MoveToTarget(std::sync::Arc<ai::MoveToTarget>),
    ChooseSkill(std::sync::Arc<ai::ChooseSkill>),
    MoveToRandomLocation(std::sync::Arc<ai::MoveToRandomLocation>),
    MoveToLocation(std::sync::Arc<ai::MoveToLocation>),
    DebugPrint(std::sync::Arc<ai::DebugPrint>),
}

impl Node {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::UeSetDefaultFocus::__ID__ => Ok(Self::UeSetDefaultFocus(std::sync::Arc::new(ai::UeSetDefaultFocus::new(buf)?))),
            ai::ExecuteTimeStatistic::__ID__ => Ok(Self::ExecuteTimeStatistic(std::sync::Arc::new(ai::ExecuteTimeStatistic::new(buf)?))),
            ai::ChooseTarget::__ID__ => Ok(Self::ChooseTarget(std::sync::Arc::new(ai::ChooseTarget::new(buf)?))),
            ai::KeepFaceTarget::__ID__ => Ok(Self::KeepFaceTarget(std::sync::Arc::new(ai::KeepFaceTarget::new(buf)?))),
            ai::GetOwnerPlayer::__ID__ => Ok(Self::GetOwnerPlayer(std::sync::Arc::new(ai::GetOwnerPlayer::new(buf)?))),
            ai::UpdateDailyBehaviorProps::__ID__ => Ok(Self::UpdateDailyBehaviorProps(std::sync::Arc::new(ai::UpdateDailyBehaviorProps::new(buf)?))),
            ai::UeLoop::__ID__ => Ok(Self::UeLoop(std::sync::Arc::new(ai::UeLoop::new(buf)?))),
            ai::UeCooldown::__ID__ => Ok(Self::UeCooldown(std::sync::Arc::new(ai::UeCooldown::new(buf)?))),
            ai::UeTimeLimit::__ID__ => Ok(Self::UeTimeLimit(std::sync::Arc::new(ai::UeTimeLimit::new(buf)?))),
            ai::UeBlackboard::__ID__ => Ok(Self::UeBlackboard(std::sync::Arc::new(ai::UeBlackboard::new(buf)?))),
            ai::UeForceSuccess::__ID__ => Ok(Self::UeForceSuccess(std::sync::Arc::new(ai::UeForceSuccess::new(buf)?))),
            ai::IsAtLocation::__ID__ => Ok(Self::IsAtLocation(std::sync::Arc::new(ai::IsAtLocation::new(buf)?))),
            ai::DistanceLessThan::__ID__ => Ok(Self::DistanceLessThan(std::sync::Arc::new(ai::DistanceLessThan::new(buf)?))),
            ai::Sequence::__ID__ => Ok(Self::Sequence(std::sync::Arc::new(ai::Sequence::new(buf)?))),
            ai::Selector::__ID__ => Ok(Self::Selector(std::sync::Arc::new(ai::Selector::new(buf)?))),
            ai::SimpleParallel::__ID__ => Ok(Self::SimpleParallel(std::sync::Arc::new(ai::SimpleParallel::new(buf)?))),
            ai::UeWait::__ID__ => Ok(Self::UeWait(std::sync::Arc::new(ai::UeWait::new(buf)?))),
            ai::UeWaitBlackboardTime::__ID__ => Ok(Self::UeWaitBlackboardTime(std::sync::Arc::new(ai::UeWaitBlackboardTime::new(buf)?))),
            ai::MoveToTarget::__ID__ => Ok(Self::MoveToTarget(std::sync::Arc::new(ai::MoveToTarget::new(buf)?))),
            ai::ChooseSkill::__ID__ => Ok(Self::ChooseSkill(std::sync::Arc::new(ai::ChooseSkill::new(buf)?))),
            ai::MoveToRandomLocation::__ID__ => Ok(Self::MoveToRandomLocation(std::sync::Arc::new(ai::MoveToRandomLocation::new(buf)?))),
            ai::MoveToLocation::__ID__ => Ok(Self::MoveToLocation(std::sync::Arc::new(ai::MoveToLocation::new(buf)?))),
            ai::DebugPrint::__ID__ => Ok(Self::DebugPrint(std::sync::Arc::new(ai::DebugPrint::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Node:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.id }
            Self::ExecuteTimeStatistic(x) => { &x.id }
            Self::ChooseTarget(x) => { &x.id }
            Self::KeepFaceTarget(x) => { &x.id }
            Self::GetOwnerPlayer(x) => { &x.id }
            Self::UpdateDailyBehaviorProps(x) => { &x.id }
            Self::UeLoop(x) => { &x.id }
            Self::UeCooldown(x) => { &x.id }
            Self::UeTimeLimit(x) => { &x.id }
            Self::UeBlackboard(x) => { &x.id }
            Self::UeForceSuccess(x) => { &x.id }
            Self::IsAtLocation(x) => { &x.id }
            Self::DistanceLessThan(x) => { &x.id }
            Self::Sequence(x) => { &x.id }
            Self::Selector(x) => { &x.id }
            Self::SimpleParallel(x) => { &x.id }
            Self::UeWait(x) => { &x.id }
            Self::UeWaitBlackboardTime(x) => { &x.id }
            Self::MoveToTarget(x) => { &x.id }
            Self::ChooseSkill(x) => { &x.id }
            Self::MoveToRandomLocation(x) => { &x.id }
            Self::MoveToLocation(x) => { &x.id }
            Self::DebugPrint(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.node_name }
            Self::ExecuteTimeStatistic(x) => { &x.node_name }
            Self::ChooseTarget(x) => { &x.node_name }
            Self::KeepFaceTarget(x) => { &x.node_name }
            Self::GetOwnerPlayer(x) => { &x.node_name }
            Self::UpdateDailyBehaviorProps(x) => { &x.node_name }
            Self::UeLoop(x) => { &x.node_name }
            Self::UeCooldown(x) => { &x.node_name }
            Self::UeTimeLimit(x) => { &x.node_name }
            Self::UeBlackboard(x) => { &x.node_name }
            Self::UeForceSuccess(x) => { &x.node_name }
            Self::IsAtLocation(x) => { &x.node_name }
            Self::DistanceLessThan(x) => { &x.node_name }
            Self::Sequence(x) => { &x.node_name }
            Self::Selector(x) => { &x.node_name }
            Self::SimpleParallel(x) => { &x.node_name }
            Self::UeWait(x) => { &x.node_name }
            Self::UeWaitBlackboardTime(x) => { &x.node_name }
            Self::MoveToTarget(x) => { &x.node_name }
            Self::ChooseSkill(x) => { &x.node_name }
            Self::MoveToRandomLocation(x) => { &x.node_name }
            Self::MoveToLocation(x) => { &x.node_name }
            Self::DebugPrint(x) => { &x.node_name }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeSetDefaultFocus(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeSetDefaultFocus as *mut ai::UeSetDefaultFocus); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ExecuteTimeStatistic(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::ExecuteTimeStatistic as *mut ai::ExecuteTimeStatistic); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::ChooseTarget as *mut ai::ChooseTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::KeepFaceTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::KeepFaceTarget as *mut ai::KeepFaceTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::GetOwnerPlayer(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::GetOwnerPlayer as *mut ai::GetOwnerPlayer); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UpdateDailyBehaviorProps(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UpdateDailyBehaviorProps as *mut ai::UpdateDailyBehaviorProps); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeLoop(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeLoop as *mut ai::UeLoop); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeCooldown(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeCooldown as *mut ai::UeCooldown); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeTimeLimit(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeTimeLimit as *mut ai::UeTimeLimit); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeBlackboard(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeBlackboard as *mut ai::UeBlackboard); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeForceSuccess(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeForceSuccess as *mut ai::UeForceSuccess); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IsAtLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::IsAtLocation as *mut ai::IsAtLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DistanceLessThan(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::DistanceLessThan as *mut ai::DistanceLessThan); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Sequence(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::Sequence as *mut ai::Sequence); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Selector(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::Selector as *mut ai::Selector); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::SimpleParallel(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::SimpleParallel as *mut ai::SimpleParallel); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWait(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeWait as *mut ai::UeWait); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWaitBlackboardTime(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeWaitBlackboardTime as *mut ai::UeWaitBlackboardTime); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToTarget as *mut ai::MoveToTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseSkill(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::ChooseSkill as *mut ai::ChooseSkill); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToRandomLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToRandomLocation as *mut ai::MoveToRandomLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToLocation as *mut ai::MoveToLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DebugPrint(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::DebugPrint as *mut ai::DebugPrint); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub enum Decorator {
    UeLoop(std::sync::Arc<ai::UeLoop>),
    UeCooldown(std::sync::Arc<ai::UeCooldown>),
    UeTimeLimit(std::sync::Arc<ai::UeTimeLimit>),
    UeBlackboard(std::sync::Arc<ai::UeBlackboard>),
    UeForceSuccess(std::sync::Arc<ai::UeForceSuccess>),
    IsAtLocation(std::sync::Arc<ai::IsAtLocation>),
    DistanceLessThan(std::sync::Arc<ai::DistanceLessThan>),
}

impl Decorator {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::UeLoop::__ID__ => Ok(Self::UeLoop(std::sync::Arc::new(ai::UeLoop::new(buf)?))),
            ai::UeCooldown::__ID__ => Ok(Self::UeCooldown(std::sync::Arc::new(ai::UeCooldown::new(buf)?))),
            ai::UeTimeLimit::__ID__ => Ok(Self::UeTimeLimit(std::sync::Arc::new(ai::UeTimeLimit::new(buf)?))),
            ai::UeBlackboard::__ID__ => Ok(Self::UeBlackboard(std::sync::Arc::new(ai::UeBlackboard::new(buf)?))),
            ai::UeForceSuccess::__ID__ => Ok(Self::UeForceSuccess(std::sync::Arc::new(ai::UeForceSuccess::new(buf)?))),
            ai::IsAtLocation::__ID__ => Ok(Self::IsAtLocation(std::sync::Arc::new(ai::IsAtLocation::new(buf)?))),
            ai::DistanceLessThan::__ID__ => Ok(Self::DistanceLessThan(std::sync::Arc::new(ai::DistanceLessThan::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Decorator:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeLoop(x) => { &x.id }
            Self::UeCooldown(x) => { &x.id }
            Self::UeTimeLimit(x) => { &x.id }
            Self::UeBlackboard(x) => { &x.id }
            Self::UeForceSuccess(x) => { &x.id }
            Self::IsAtLocation(x) => { &x.id }
            Self::DistanceLessThan(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeLoop(x) => { &x.node_name }
            Self::UeCooldown(x) => { &x.node_name }
            Self::UeTimeLimit(x) => { &x.node_name }
            Self::UeBlackboard(x) => { &x.node_name }
            Self::UeForceSuccess(x) => { &x.node_name }
            Self::IsAtLocation(x) => { &x.node_name }
            Self::DistanceLessThan(x) => { &x.node_name }
        }
    }    
    
    pub fn get_flow_abort_mode(&self) -> &ai::EFlowAbortMode {
        match self {
            Self::UeLoop(x) => { &x.flow_abort_mode }
            Self::UeCooldown(x) => { &x.flow_abort_mode }
            Self::UeTimeLimit(x) => { &x.flow_abort_mode }
            Self::UeBlackboard(x) => { &x.flow_abort_mode }
            Self::UeForceSuccess(x) => { &x.flow_abort_mode }
            Self::IsAtLocation(x) => { &x.flow_abort_mode }
            Self::DistanceLessThan(x) => { &x.flow_abort_mode }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeLoop(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeLoop as *mut ai::UeLoop); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeCooldown(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeCooldown as *mut ai::UeCooldown); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeTimeLimit(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeTimeLimit as *mut ai::UeTimeLimit); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeBlackboard(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeBlackboard as *mut ai::UeBlackboard); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeForceSuccess(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeForceSuccess as *mut ai::UeForceSuccess); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IsAtLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::IsAtLocation as *mut ai::IsAtLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DistanceLessThan(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::DistanceLessThan as *mut ai::DistanceLessThan); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct DistanceLessThan {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: ai::EFlowAbortMode,
    pub actor1_key: String,
    pub actor2_key: String,
    pub distance: f32,
    pub reverse_result: bool,
}

impl DistanceLessThan{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DistanceLessThan, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = Into::<ai::EFlowAbortMode>::into(buf.read_int());
        let actor1_key = buf.read_string();
        let actor2_key = buf.read_string();
        let distance = buf.read_float();
        let reverse_result = buf.read_bool();
        
        Ok(DistanceLessThan { id, node_name, flow_abort_mode, actor1_key, actor2_key, distance, reverse_result, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1207170283;
}

#[derive(Debug)]
pub struct IsAtLocation {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: ai::EFlowAbortMode,
    pub acceptable_radius: f32,
    pub keyboard_key: String,
    pub inverse_condition: bool,
}

impl IsAtLocation{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<IsAtLocation, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = Into::<ai::EFlowAbortMode>::into(buf.read_int());
        let acceptable_radius = buf.read_float();
        let keyboard_key = buf.read_string();
        let inverse_condition = buf.read_bool();
        
        Ok(IsAtLocation { id, node_name, flow_abort_mode, acceptable_radius, keyboard_key, inverse_condition, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1255972344;
}

#[derive(Debug)]
pub struct UeBlackboard {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: ai::EFlowAbortMode,
    pub notify_observer: ai::ENotifyObserverMode,
    pub blackboard_key: String,
    pub key_query: ai::KeyQueryOperator,
}

impl UeBlackboard{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeBlackboard, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = Into::<ai::EFlowAbortMode>::into(buf.read_int());
        let notify_observer = Into::<ai::ENotifyObserverMode>::into(buf.read_int());
        let blackboard_key = buf.read_string();
        let key_query = ai::KeyQueryOperator::new(&mut buf)?;
        
        Ok(UeBlackboard { id, node_name, flow_abort_mode, notify_observer, blackboard_key, key_query, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.key_query.resolve_ref(tables);
    }

    pub const __ID__: i32 = -315297507;
}

#[derive(Debug)]
pub struct UeCooldown {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: ai::EFlowAbortMode,
    pub cooldown_time: f32,
}

impl UeCooldown{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeCooldown, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = Into::<ai::EFlowAbortMode>::into(buf.read_int());
        let cooldown_time = buf.read_float();
        
        Ok(UeCooldown { id, node_name, flow_abort_mode, cooldown_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -951439423;
}

#[derive(Debug)]
pub struct UeForceSuccess {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: ai::EFlowAbortMode,
}

impl UeForceSuccess{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeForceSuccess, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = Into::<ai::EFlowAbortMode>::into(buf.read_int());
        
        Ok(UeForceSuccess { id, node_name, flow_abort_mode, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 195054574;
}

#[derive(Debug)]
pub struct UeLoop {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: ai::EFlowAbortMode,
    pub num_loops: i32,
    pub infinite_loop: bool,
    pub infinite_loop_timeout_time: f32,
}

impl UeLoop{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeLoop, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = Into::<ai::EFlowAbortMode>::into(buf.read_int());
        let num_loops = buf.read_int();
        let infinite_loop = buf.read_bool();
        let infinite_loop_timeout_time = buf.read_float();
        
        Ok(UeLoop { id, node_name, flow_abort_mode, num_loops, infinite_loop, infinite_loop_timeout_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -513308166;
}

#[derive(Debug)]
pub struct UeTimeLimit {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: ai::EFlowAbortMode,
    pub limit_time: f32,
}

impl UeTimeLimit{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeTimeLimit, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let flow_abort_mode = Into::<ai::EFlowAbortMode>::into(buf.read_int());
        let limit_time = buf.read_float();
        
        Ok(UeTimeLimit { id, node_name, flow_abort_mode, limit_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 338469720;
}

#[derive(Debug)]
pub enum FlowNode {
    Sequence(std::sync::Arc<ai::Sequence>),
    Selector(std::sync::Arc<ai::Selector>),
    SimpleParallel(std::sync::Arc<ai::SimpleParallel>),
    UeWait(std::sync::Arc<ai::UeWait>),
    UeWaitBlackboardTime(std::sync::Arc<ai::UeWaitBlackboardTime>),
    MoveToTarget(std::sync::Arc<ai::MoveToTarget>),
    ChooseSkill(std::sync::Arc<ai::ChooseSkill>),
    MoveToRandomLocation(std::sync::Arc<ai::MoveToRandomLocation>),
    MoveToLocation(std::sync::Arc<ai::MoveToLocation>),
    DebugPrint(std::sync::Arc<ai::DebugPrint>),
}

impl FlowNode {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::Sequence::__ID__ => Ok(Self::Sequence(std::sync::Arc::new(ai::Sequence::new(buf)?))),
            ai::Selector::__ID__ => Ok(Self::Selector(std::sync::Arc::new(ai::Selector::new(buf)?))),
            ai::SimpleParallel::__ID__ => Ok(Self::SimpleParallel(std::sync::Arc::new(ai::SimpleParallel::new(buf)?))),
            ai::UeWait::__ID__ => Ok(Self::UeWait(std::sync::Arc::new(ai::UeWait::new(buf)?))),
            ai::UeWaitBlackboardTime::__ID__ => Ok(Self::UeWaitBlackboardTime(std::sync::Arc::new(ai::UeWaitBlackboardTime::new(buf)?))),
            ai::MoveToTarget::__ID__ => Ok(Self::MoveToTarget(std::sync::Arc::new(ai::MoveToTarget::new(buf)?))),
            ai::ChooseSkill::__ID__ => Ok(Self::ChooseSkill(std::sync::Arc::new(ai::ChooseSkill::new(buf)?))),
            ai::MoveToRandomLocation::__ID__ => Ok(Self::MoveToRandomLocation(std::sync::Arc::new(ai::MoveToRandomLocation::new(buf)?))),
            ai::MoveToLocation::__ID__ => Ok(Self::MoveToLocation(std::sync::Arc::new(ai::MoveToLocation::new(buf)?))),
            ai::DebugPrint::__ID__ => Ok(Self::DebugPrint(std::sync::Arc::new(ai::DebugPrint::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for FlowNode:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::Sequence(x) => { &x.id }
            Self::Selector(x) => { &x.id }
            Self::SimpleParallel(x) => { &x.id }
            Self::UeWait(x) => { &x.id }
            Self::UeWaitBlackboardTime(x) => { &x.id }
            Self::MoveToTarget(x) => { &x.id }
            Self::ChooseSkill(x) => { &x.id }
            Self::MoveToRandomLocation(x) => { &x.id }
            Self::MoveToLocation(x) => { &x.id }
            Self::DebugPrint(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::Sequence(x) => { &x.node_name }
            Self::Selector(x) => { &x.node_name }
            Self::SimpleParallel(x) => { &x.node_name }
            Self::UeWait(x) => { &x.node_name }
            Self::UeWaitBlackboardTime(x) => { &x.node_name }
            Self::MoveToTarget(x) => { &x.node_name }
            Self::ChooseSkill(x) => { &x.node_name }
            Self::MoveToRandomLocation(x) => { &x.node_name }
            Self::MoveToLocation(x) => { &x.node_name }
            Self::DebugPrint(x) => { &x.node_name }
        }
    }    
    
    pub fn get_decorators(&self) -> &Vec<ai::Decorator> {
        match self {
            Self::Sequence(x) => { &x.decorators }
            Self::Selector(x) => { &x.decorators }
            Self::SimpleParallel(x) => { &x.decorators }
            Self::UeWait(x) => { &x.decorators }
            Self::UeWaitBlackboardTime(x) => { &x.decorators }
            Self::MoveToTarget(x) => { &x.decorators }
            Self::ChooseSkill(x) => { &x.decorators }
            Self::MoveToRandomLocation(x) => { &x.decorators }
            Self::MoveToLocation(x) => { &x.decorators }
            Self::DebugPrint(x) => { &x.decorators }
        }
    }    
    
    pub fn get_services(&self) -> &Vec<ai::Service> {
        match self {
            Self::Sequence(x) => { &x.services }
            Self::Selector(x) => { &x.services }
            Self::SimpleParallel(x) => { &x.services }
            Self::UeWait(x) => { &x.services }
            Self::UeWaitBlackboardTime(x) => { &x.services }
            Self::MoveToTarget(x) => { &x.services }
            Self::ChooseSkill(x) => { &x.services }
            Self::MoveToRandomLocation(x) => { &x.services }
            Self::MoveToLocation(x) => { &x.services }
            Self::DebugPrint(x) => { &x.services }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Sequence(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::Sequence as *mut ai::Sequence); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Selector(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::Selector as *mut ai::Selector); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::SimpleParallel(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::SimpleParallel as *mut ai::SimpleParallel); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWait(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeWait as *mut ai::UeWait); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWaitBlackboardTime(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeWaitBlackboardTime as *mut ai::UeWaitBlackboardTime); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToTarget as *mut ai::MoveToTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseSkill(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::ChooseSkill as *mut ai::ChooseSkill); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToRandomLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToRandomLocation as *mut ai::MoveToRandomLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToLocation as *mut ai::MoveToLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DebugPrint(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::DebugPrint as *mut ai::DebugPrint); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub enum ComposeNode {
    Sequence(std::sync::Arc<ai::Sequence>),
    Selector(std::sync::Arc<ai::Selector>),
    SimpleParallel(std::sync::Arc<ai::SimpleParallel>),
}

impl ComposeNode {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::Sequence::__ID__ => Ok(Self::Sequence(std::sync::Arc::new(ai::Sequence::new(buf)?))),
            ai::Selector::__ID__ => Ok(Self::Selector(std::sync::Arc::new(ai::Selector::new(buf)?))),
            ai::SimpleParallel::__ID__ => Ok(Self::SimpleParallel(std::sync::Arc::new(ai::SimpleParallel::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for ComposeNode:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::Sequence(x) => { &x.id }
            Self::Selector(x) => { &x.id }
            Self::SimpleParallel(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::Sequence(x) => { &x.node_name }
            Self::Selector(x) => { &x.node_name }
            Self::SimpleParallel(x) => { &x.node_name }
        }
    }    
    
    pub fn get_decorators(&self) -> &Vec<ai::Decorator> {
        match self {
            Self::Sequence(x) => { &x.decorators }
            Self::Selector(x) => { &x.decorators }
            Self::SimpleParallel(x) => { &x.decorators }
        }
    }    
    
    pub fn get_services(&self) -> &Vec<ai::Service> {
        match self {
            Self::Sequence(x) => { &x.services }
            Self::Selector(x) => { &x.services }
            Self::SimpleParallel(x) => { &x.services }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Sequence(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::Sequence as *mut ai::Sequence); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Selector(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::Selector as *mut ai::Selector); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::SimpleParallel(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::SimpleParallel as *mut ai::SimpleParallel); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct Selector {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub children: Vec<ai::FlowNode>,
}

impl Selector{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Selector, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let children = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::FlowNode::new(&mut buf)?); } _e0 };
        
        Ok(Selector { id, node_name, decorators, services, children, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.children.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -1946981627;
}

#[derive(Debug)]
pub struct Sequence {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub children: Vec<ai::FlowNode>,
}

impl Sequence{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Sequence, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let children = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::FlowNode::new(&mut buf)?); } _e0 };
        
        Ok(Sequence { id, node_name, decorators, services, children, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.children.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -1789006105;
}

#[derive(Debug)]
pub struct SimpleParallel {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub finish_mode: ai::EFinishMode,
    pub main_task: ai::Task,
    pub background_node: ai::FlowNode,
}

impl SimpleParallel{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<SimpleParallel, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let finish_mode = Into::<ai::EFinishMode>::into(buf.read_int());
        let main_task = ai::Task::new(&mut buf)?;
        let background_node = ai::FlowNode::new(&mut buf)?;
        
        Ok(SimpleParallel { id, node_name, decorators, services, finish_mode, main_task, background_node, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.main_task.resolve_ref(tables);
        self.background_node.resolve_ref(tables);
    }

    pub const __ID__: i32 = -1952582529;
}

#[derive(Debug)]
pub enum Task {
    UeWait(std::sync::Arc<ai::UeWait>),
    UeWaitBlackboardTime(std::sync::Arc<ai::UeWaitBlackboardTime>),
    MoveToTarget(std::sync::Arc<ai::MoveToTarget>),
    ChooseSkill(std::sync::Arc<ai::ChooseSkill>),
    MoveToRandomLocation(std::sync::Arc<ai::MoveToRandomLocation>),
    MoveToLocation(std::sync::Arc<ai::MoveToLocation>),
    DebugPrint(std::sync::Arc<ai::DebugPrint>),
}

impl Task {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::UeWait::__ID__ => Ok(Self::UeWait(std::sync::Arc::new(ai::UeWait::new(buf)?))),
            ai::UeWaitBlackboardTime::__ID__ => Ok(Self::UeWaitBlackboardTime(std::sync::Arc::new(ai::UeWaitBlackboardTime::new(buf)?))),
            ai::MoveToTarget::__ID__ => Ok(Self::MoveToTarget(std::sync::Arc::new(ai::MoveToTarget::new(buf)?))),
            ai::ChooseSkill::__ID__ => Ok(Self::ChooseSkill(std::sync::Arc::new(ai::ChooseSkill::new(buf)?))),
            ai::MoveToRandomLocation::__ID__ => Ok(Self::MoveToRandomLocation(std::sync::Arc::new(ai::MoveToRandomLocation::new(buf)?))),
            ai::MoveToLocation::__ID__ => Ok(Self::MoveToLocation(std::sync::Arc::new(ai::MoveToLocation::new(buf)?))),
            ai::DebugPrint::__ID__ => Ok(Self::DebugPrint(std::sync::Arc::new(ai::DebugPrint::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Task:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeWait(x) => { &x.id }
            Self::UeWaitBlackboardTime(x) => { &x.id }
            Self::MoveToTarget(x) => { &x.id }
            Self::ChooseSkill(x) => { &x.id }
            Self::MoveToRandomLocation(x) => { &x.id }
            Self::MoveToLocation(x) => { &x.id }
            Self::DebugPrint(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeWait(x) => { &x.node_name }
            Self::UeWaitBlackboardTime(x) => { &x.node_name }
            Self::MoveToTarget(x) => { &x.node_name }
            Self::ChooseSkill(x) => { &x.node_name }
            Self::MoveToRandomLocation(x) => { &x.node_name }
            Self::MoveToLocation(x) => { &x.node_name }
            Self::DebugPrint(x) => { &x.node_name }
        }
    }    
    
    pub fn get_decorators(&self) -> &Vec<ai::Decorator> {
        match self {
            Self::UeWait(x) => { &x.decorators }
            Self::UeWaitBlackboardTime(x) => { &x.decorators }
            Self::MoveToTarget(x) => { &x.decorators }
            Self::ChooseSkill(x) => { &x.decorators }
            Self::MoveToRandomLocation(x) => { &x.decorators }
            Self::MoveToLocation(x) => { &x.decorators }
            Self::DebugPrint(x) => { &x.decorators }
        }
    }    
    
    pub fn get_services(&self) -> &Vec<ai::Service> {
        match self {
            Self::UeWait(x) => { &x.services }
            Self::UeWaitBlackboardTime(x) => { &x.services }
            Self::MoveToTarget(x) => { &x.services }
            Self::ChooseSkill(x) => { &x.services }
            Self::MoveToRandomLocation(x) => { &x.services }
            Self::MoveToLocation(x) => { &x.services }
            Self::DebugPrint(x) => { &x.services }
        }
    }    
    
    pub fn get_ignore_restart_self(&self) -> &bool {
        match self {
            Self::UeWait(x) => { &x.ignore_restart_self }
            Self::UeWaitBlackboardTime(x) => { &x.ignore_restart_self }
            Self::MoveToTarget(x) => { &x.ignore_restart_self }
            Self::ChooseSkill(x) => { &x.ignore_restart_self }
            Self::MoveToRandomLocation(x) => { &x.ignore_restart_self }
            Self::MoveToLocation(x) => { &x.ignore_restart_self }
            Self::DebugPrint(x) => { &x.ignore_restart_self }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeWait(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeWait as *mut ai::UeWait); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWaitBlackboardTime(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeWaitBlackboardTime as *mut ai::UeWaitBlackboardTime); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToTarget as *mut ai::MoveToTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseSkill(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::ChooseSkill as *mut ai::ChooseSkill); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToRandomLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToRandomLocation as *mut ai::MoveToRandomLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::MoveToLocation as *mut ai::MoveToLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DebugPrint(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::DebugPrint as *mut ai::DebugPrint); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct ChooseSkill {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub result_skill_id_key: String,
}

impl ChooseSkill{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ChooseSkill, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let target_actor_key = buf.read_string();
        let result_skill_id_key = buf.read_string();
        
        Ok(ChooseSkill { id, node_name, decorators, services, ignore_restart_self, target_actor_key, result_skill_id_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -918812268;
}

#[derive(Debug)]
pub struct DebugPrint {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub ignore_restart_self: bool,
    pub text: String,
}

impl DebugPrint{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DebugPrint, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let text = buf.read_string();
        
        Ok(DebugPrint { id, node_name, decorators, services, ignore_restart_self, text, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 1357409728;
}

#[derive(Debug)]
pub struct MoveToLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub ignore_restart_self: bool,
    pub acceptable_radius: f32,
}

impl MoveToLocation{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MoveToLocation, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let acceptable_radius = buf.read_float();
        
        Ok(MoveToLocation { id, node_name, decorators, services, ignore_restart_self, acceptable_radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -969953113;
}

#[derive(Debug)]
pub struct MoveToRandomLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub ignore_restart_self: bool,
    pub origin_position_key: String,
    pub radius: f32,
}

impl MoveToRandomLocation{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MoveToRandomLocation, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let origin_position_key = buf.read_string();
        let radius = buf.read_float();
        
        Ok(MoveToRandomLocation { id, node_name, decorators, services, ignore_restart_self, origin_position_key, radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -2140042998;
}

#[derive(Debug)]
pub struct MoveToTarget {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub acceptable_radius: f32,
}

impl MoveToTarget{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MoveToTarget, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let target_actor_key = buf.read_string();
        let acceptable_radius = buf.read_float();
        
        Ok(MoveToTarget { id, node_name, decorators, services, ignore_restart_self, target_actor_key, acceptable_radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 514987779;
}

#[derive(Debug)]
pub struct UeWait {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub ignore_restart_self: bool,
    pub wait_time: f32,
    pub random_deviation: f32,
}

impl UeWait{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeWait, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let wait_time = buf.read_float();
        let random_deviation = buf.read_float();
        
        Ok(UeWait { id, node_name, decorators, services, ignore_restart_self, wait_time, random_deviation, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -512994101;
}

#[derive(Debug)]
pub struct UeWaitBlackboardTime {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<ai::Decorator>,
    pub services: Vec<ai::Service>,
    pub ignore_restart_self: bool,
    pub blackboard_key: String,
}

impl UeWaitBlackboardTime{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeWaitBlackboardTime, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let decorators = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Decorator::new(&mut buf)?); } _e0 };
        let services = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(ai::Service::new(&mut buf)?); } _e0 };
        let ignore_restart_self = buf.read_bool();
        let blackboard_key = buf.read_string();
        
        Ok(UeWaitBlackboardTime { id, node_name, decorators, services, ignore_restart_self, blackboard_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 1215378271;
}

#[derive(Debug)]
pub enum Service {
    UeSetDefaultFocus(std::sync::Arc<ai::UeSetDefaultFocus>),
    ExecuteTimeStatistic(std::sync::Arc<ai::ExecuteTimeStatistic>),
    ChooseTarget(std::sync::Arc<ai::ChooseTarget>),
    KeepFaceTarget(std::sync::Arc<ai::KeepFaceTarget>),
    GetOwnerPlayer(std::sync::Arc<ai::GetOwnerPlayer>),
    UpdateDailyBehaviorProps(std::sync::Arc<ai::UpdateDailyBehaviorProps>),
}

impl Service {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            ai::UeSetDefaultFocus::__ID__ => Ok(Self::UeSetDefaultFocus(std::sync::Arc::new(ai::UeSetDefaultFocus::new(buf)?))),
            ai::ExecuteTimeStatistic::__ID__ => Ok(Self::ExecuteTimeStatistic(std::sync::Arc::new(ai::ExecuteTimeStatistic::new(buf)?))),
            ai::ChooseTarget::__ID__ => Ok(Self::ChooseTarget(std::sync::Arc::new(ai::ChooseTarget::new(buf)?))),
            ai::KeepFaceTarget::__ID__ => Ok(Self::KeepFaceTarget(std::sync::Arc::new(ai::KeepFaceTarget::new(buf)?))),
            ai::GetOwnerPlayer::__ID__ => Ok(Self::GetOwnerPlayer(std::sync::Arc::new(ai::GetOwnerPlayer::new(buf)?))),
            ai::UpdateDailyBehaviorProps::__ID__ => Ok(Self::UpdateDailyBehaviorProps(std::sync::Arc::new(ai::UpdateDailyBehaviorProps::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Service:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.id }
            Self::ExecuteTimeStatistic(x) => { &x.id }
            Self::ChooseTarget(x) => { &x.id }
            Self::KeepFaceTarget(x) => { &x.id }
            Self::GetOwnerPlayer(x) => { &x.id }
            Self::UpdateDailyBehaviorProps(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.node_name }
            Self::ExecuteTimeStatistic(x) => { &x.node_name }
            Self::ChooseTarget(x) => { &x.node_name }
            Self::KeepFaceTarget(x) => { &x.node_name }
            Self::GetOwnerPlayer(x) => { &x.node_name }
            Self::UpdateDailyBehaviorProps(x) => { &x.node_name }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeSetDefaultFocus(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UeSetDefaultFocus as *mut ai::UeSetDefaultFocus); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ExecuteTimeStatistic(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::ExecuteTimeStatistic as *mut ai::ExecuteTimeStatistic); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::ChooseTarget as *mut ai::ChooseTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::KeepFaceTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::KeepFaceTarget as *mut ai::KeepFaceTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::GetOwnerPlayer(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::GetOwnerPlayer as *mut ai::GetOwnerPlayer); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UpdateDailyBehaviorProps(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const ai::UpdateDailyBehaviorProps as *mut ai::UpdateDailyBehaviorProps); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct ChooseTarget {
    pub id: i32,
    pub node_name: String,
    pub result_target_key: String,
}

impl ChooseTarget{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ChooseTarget, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let result_target_key = buf.read_string();
        
        Ok(ChooseTarget { id, node_name, result_target_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1601247918;
}

#[derive(Debug)]
pub struct ExecuteTimeStatistic {
    pub id: i32,
    pub node_name: String,
}

impl ExecuteTimeStatistic{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ExecuteTimeStatistic, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        
        Ok(ExecuteTimeStatistic { id, node_name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 990693812;
}

#[derive(Debug)]
pub struct GetOwnerPlayer {
    pub id: i32,
    pub node_name: String,
    pub player_actor_key: String,
}

impl GetOwnerPlayer{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<GetOwnerPlayer, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let player_actor_key = buf.read_string();
        
        Ok(GetOwnerPlayer { id, node_name, player_actor_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -999247644;
}

#[derive(Debug)]
pub struct KeepFaceTarget {
    pub id: i32,
    pub node_name: String,
    pub target_actor_key: String,
}

impl KeepFaceTarget{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<KeepFaceTarget, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let target_actor_key = buf.read_string();
        
        Ok(KeepFaceTarget { id, node_name, target_actor_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1195270745;
}

#[derive(Debug)]
pub struct UeSetDefaultFocus {
    pub id: i32,
    pub node_name: String,
    pub keyboard_key: String,
}

impl UeSetDefaultFocus{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UeSetDefaultFocus, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let keyboard_key = buf.read_string();
        
        Ok(UeSetDefaultFocus { id, node_name, keyboard_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1812449155;
}

#[derive(Debug)]
pub struct UpdateDailyBehaviorProps {
    pub id: i32,
    pub node_name: String,
    pub satiety_key: String,
    pub energy_key: String,
    pub mood_key: String,
    pub satiety_lower_threshold_key: String,
    pub satiety_upper_threshold_key: String,
    pub energy_lower_threshold_key: String,
    pub energy_upper_threshold_key: String,
    pub mood_lower_threshold_key: String,
    pub mood_upper_threshold_key: String,
}

impl UpdateDailyBehaviorProps{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<UpdateDailyBehaviorProps, LubanError> {
        let id = buf.read_int();
        let node_name = buf.read_string();
        let satiety_key = buf.read_string();
        let energy_key = buf.read_string();
        let mood_key = buf.read_string();
        let satiety_lower_threshold_key = buf.read_string();
        let satiety_upper_threshold_key = buf.read_string();
        let energy_lower_threshold_key = buf.read_string();
        let energy_upper_threshold_key = buf.read_string();
        let mood_lower_threshold_key = buf.read_string();
        let mood_upper_threshold_key = buf.read_string();
        
        Ok(UpdateDailyBehaviorProps { id, node_name, satiety_key, energy_key, mood_key, satiety_lower_threshold_key, satiety_upper_threshold_key, energy_lower_threshold_key, energy_upper_threshold_key, mood_lower_threshold_key, mood_upper_threshold_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -61887372;
}


#[derive(Debug)]
pub struct TbBlackboard {
    pub data_list: Vec<std::sync::Arc<ai::Blackboard>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<ai::Blackboard>>,
}

impl TbBlackboard {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbBlackboard>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<ai::Blackboard>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<ai::Blackboard>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(ai::Blackboard::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.name.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBlackboard { data_map, data_list }))
    }

    pub fn get(&self, key: &String) -> Option<std::sync::Arc<ai::Blackboard>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const ai::Blackboard as *mut ai::Blackboard); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<String> for TbBlackboard {
    type Output = std::sync::Arc<ai::Blackboard>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbBehaviorTree {
    pub data_list: Vec<std::sync::Arc<ai::BehaviorTree>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<ai::BehaviorTree>>,
}

impl TbBehaviorTree {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbBehaviorTree>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<ai::BehaviorTree>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<ai::BehaviorTree>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(ai::BehaviorTree::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBehaviorTree { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<ai::BehaviorTree>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const ai::BehaviorTree as *mut ai::BehaviorTree); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbBehaviorTree {
    type Output = std::sync::Arc<ai::BehaviorTree>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


