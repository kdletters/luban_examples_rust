
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

#![allow(warnings)]
#![allow(clippy::all)]
pub mod prelude {
    pub use super::*;
    pub use super::ai::*;
    pub use super::common::*;
    pub use super::item::*;
    pub use super::l10n::*;
    pub use super::tag::*;
    pub use super::test::*;
    pub use super::test::login::*;
    pub use super::test2::*;
}

#[derive(Debug)]
pub enum LubanError {
    Loader(String),
    Table(String),
    Bean(String),
    Polymorphic(String),
    Unknown(String),
}

impl std::fmt::Display for LubanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(match self {
            LubanError::Loader(msg) |
            LubanError::Table(msg) |
            LubanError::Bean(msg) |
            LubanError::Polymorphic(msg) |
            LubanError::Unknown(msg) => msg,
        })
    }
}

pub struct Tables{
    pub TbBlackboard: std::sync::Arc<ai::TbBlackboard>,
    pub TbBehaviorTree: std::sync::Arc<ai::TbBehaviorTree>,
    pub TbGlobalConfig: std::sync::Arc<common::TbGlobalConfig>,
    pub TbItem: std::sync::Arc<item::TbItem>,
    pub TbL10NDemo: std::sync::Arc<l10n::TbL10NDemo>,
    pub TbPatchDemo: std::sync::Arc<l10n::TbPatchDemo>,
    pub TbTestTag: std::sync::Arc<tag::TbTestTag>,
    pub TbFullTypes: std::sync::Arc<test::TbFullTypes>,
    pub TbSingleton: std::sync::Arc<test::TbSingleton>,
    pub TbNotIndexList: std::sync::Arc<test::TbNotIndexList>,
    pub TbMultiUnionIndexList: std::sync::Arc<test::TbMultiUnionIndexList>,
    pub TbMultiIndexList: std::sync::Arc<test::TbMultiIndexList>,
    pub TbDataFromMisc: std::sync::Arc<test::TbDataFromMisc>,
    pub TbMultiRowRecord: std::sync::Arc<test::TbMultiRowRecord>,
    pub TbTestMultiColumn: std::sync::Arc<test::TbTestMultiColumn>,
    pub TbMultiRowTitle: std::sync::Arc<test::TbMultiRowTitle>,
    pub TbTestNull: std::sync::Arc<test::TbTestNull>,
    pub TbDemoPrimitive: std::sync::Arc<test::TbDemoPrimitive>,
    pub TbTestString: std::sync::Arc<test::TbTestString>,
    pub TbDemoGroup: std::sync::Arc<test::TbDemoGroup>,
    pub TbDemoGroup_C: std::sync::Arc<test::TbDemoGroup_C>,
    pub TbDemoGroup_S: std::sync::Arc<test::TbDemoGroup_S>,
    pub TbDemoGroup_E: std::sync::Arc<test::TbDemoGroup_E>,
    pub TbTestGlobal: std::sync::Arc<test::TbTestGlobal>,
    pub TbTestBeRef: std::sync::Arc<test::TbTestBeRef>,
    pub TbTestBeRef2: std::sync::Arc<test::TbTestBeRef2>,
    pub TbTestRef: std::sync::Arc<test::TbTestRef>,
    pub TbTestSize: std::sync::Arc<test::TbTestSize>,
    pub TbTestSet: std::sync::Arc<test::TbTestSet>,
    pub TbTestRange: std::sync::Arc<test::TbTestRange>,
    pub TbDetectCsvEncoding: std::sync::Arc<test::TbDetectCsvEncoding>,
    pub TbItem2: std::sync::Arc<test::TbItem2>,
    pub TbTestIndex: std::sync::Arc<test::TbTestIndex>,
    pub TbTestMap: std::sync::Arc<test::TbTestMap>,
    pub TbExcelFromJson: std::sync::Arc<test::TbExcelFromJson>,
    pub TbCompositeJsonTable1: std::sync::Arc<test::TbCompositeJsonTable1>,
    pub TbCompositeJsonTable2: std::sync::Arc<test::TbCompositeJsonTable2>,
    pub TbCompositeJsonTable3: std::sync::Arc<test::TbCompositeJsonTable3>,
    pub TbExcelFromJsonMultiRow: std::sync::Arc<test::TbExcelFromJsonMultiRow>,
    pub TbTestScriptableObject: std::sync::Arc<test::TbTestScriptableObject>,
    pub TbPath: std::sync::Arc<test::TbPath>,
    pub TbTestFieldAlias: std::sync::Arc<test::TbTestFieldAlias>,
    pub TbTestFieldVariant: std::sync::Arc<test::TbTestFieldVariant>,
    pub TbTestFieldVariant2: std::sync::Arc<test::TbTestFieldVariant2>,
    pub TbTestMapper: std::sync::Arc<test::TbTestMapper>,
    pub TbDefineFromExcel2: std::sync::Arc<test::TbDefineFromExcel2>,
    pub TbAutoImport1: std::sync::Arc<TbAutoImport1>,
    pub TbAutoImport2: std::sync::Arc<test::TbAutoImport2>,
    pub TbTestFormat: std::sync::Arc<test::TbTestFormat>,
}

impl Tables {
    pub fn new<T: Fn(&str) -> Result<ByteBuf, LubanError>>(loader: T) -> Result<Tables, LubanError> {
        let mut tables =Tables{
            TbBlackboard: ai::TbBlackboard::new(loader("ai_tbblackboard")?)?,
            TbBehaviorTree: ai::TbBehaviorTree::new(loader("ai_tbbehaviortree")?)?,
            TbGlobalConfig: common::TbGlobalConfig::new(loader("common_tbglobalconfig")?)?,
            TbItem: item::TbItem::new(loader("item_tbitem")?)?,
            TbL10NDemo: l10n::TbL10NDemo::new(loader("l10n_tbl10ndemo")?)?,
            TbPatchDemo: l10n::TbPatchDemo::new(loader("l10n_tbpatchdemo")?)?,
            TbTestTag: tag::TbTestTag::new(loader("tag_tbtesttag")?)?,
            TbFullTypes: test::TbFullTypes::new(loader("test_tbfulltypes")?)?,
            TbSingleton: test::TbSingleton::new(loader("test_tbsingleton")?)?,
            TbNotIndexList: test::TbNotIndexList::new(loader("test_tbnotindexlist")?)?,
            TbMultiUnionIndexList: test::TbMultiUnionIndexList::new(loader("test_tbmultiunionindexlist")?)?,
            TbMultiIndexList: test::TbMultiIndexList::new(loader("test_tbmultiindexlist")?)?,
            TbDataFromMisc: test::TbDataFromMisc::new(loader("test_tbdatafrommisc")?)?,
            TbMultiRowRecord: test::TbMultiRowRecord::new(loader("test_tbmultirowrecord")?)?,
            TbTestMultiColumn: test::TbTestMultiColumn::new(loader("test_tbtestmulticolumn")?)?,
            TbMultiRowTitle: test::TbMultiRowTitle::new(loader("test_tbmultirowtitle")?)?,
            TbTestNull: test::TbTestNull::new(loader("test_tbtestnull")?)?,
            TbDemoPrimitive: test::TbDemoPrimitive::new(loader("test_tbdemoprimitive")?)?,
            TbTestString: test::TbTestString::new(loader("test_tbteststring")?)?,
            TbDemoGroup: test::TbDemoGroup::new(loader("test_tbdemogroup")?)?,
            TbDemoGroup_C: test::TbDemoGroup_C::new(loader("test_tbdemogroup_c")?)?,
            TbDemoGroup_S: test::TbDemoGroup_S::new(loader("test_tbdemogroup_s")?)?,
            TbDemoGroup_E: test::TbDemoGroup_E::new(loader("test_tbdemogroup_e")?)?,
            TbTestGlobal: test::TbTestGlobal::new(loader("test_tbtestglobal")?)?,
            TbTestBeRef: test::TbTestBeRef::new(loader("test_tbtestberef")?)?,
            TbTestBeRef2: test::TbTestBeRef2::new(loader("test_tbtestberef2")?)?,
            TbTestRef: test::TbTestRef::new(loader("test_tbtestref")?)?,
            TbTestSize: test::TbTestSize::new(loader("test_tbtestsize")?)?,
            TbTestSet: test::TbTestSet::new(loader("test_tbtestset")?)?,
            TbTestRange: test::TbTestRange::new(loader("test_tbtestrange")?)?,
            TbDetectCsvEncoding: test::TbDetectCsvEncoding::new(loader("test_tbdetectcsvencoding")?)?,
            TbItem2: test::TbItem2::new(loader("test_tbitem2")?)?,
            TbTestIndex: test::TbTestIndex::new(loader("test_tbtestindex")?)?,
            TbTestMap: test::TbTestMap::new(loader("test_tbtestmap")?)?,
            TbExcelFromJson: test::TbExcelFromJson::new(loader("test_tbexcelfromjson")?)?,
            TbCompositeJsonTable1: test::TbCompositeJsonTable1::new(loader("test_tbcompositejsontable1")?)?,
            TbCompositeJsonTable2: test::TbCompositeJsonTable2::new(loader("test_tbcompositejsontable2")?)?,
            TbCompositeJsonTable3: test::TbCompositeJsonTable3::new(loader("test_tbcompositejsontable3")?)?,
            TbExcelFromJsonMultiRow: test::TbExcelFromJsonMultiRow::new(loader("test_tbexcelfromjsonmultirow")?)?,
            TbTestScriptableObject: test::TbTestScriptableObject::new(loader("test_tbtestscriptableobject")?)?,
            TbPath: test::TbPath::new(loader("test_tbpath")?)?,
            TbTestFieldAlias: test::TbTestFieldAlias::new(loader("test_tbtestfieldalias")?)?,
            TbTestFieldVariant: test::TbTestFieldVariant::new(loader("test_tbtestfieldvariant")?)?,
            TbTestFieldVariant2: test::TbTestFieldVariant2::new(loader("test_tbtestfieldvariant2")?)?,
            TbTestMapper: test::TbTestMapper::new(loader("test_tbtestmapper")?)?,
            TbDefineFromExcel2: test::TbDefineFromExcel2::new(loader("test_tbdefinefromexcel2")?)?,
            TbAutoImport1: TbAutoImport1::new(loader("tbautoimport1")?)?,
            TbAutoImport2: test::TbAutoImport2::new(loader("test_tbautoimport2")?)?,
            TbTestFormat: test::TbTestFormat::new(loader("test_tbtestformat")?)?,
        };
        unsafe { tables.resolve_ref(); }
        Ok(tables)
    }

    unsafe fn resolve_ref(&mut self) {
        let mut b = Box::from_raw(self.TbBlackboard.as_ref() as *const ai::TbBlackboard as *mut ai::TbBlackboard); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbBehaviorTree.as_ref() as *const ai::TbBehaviorTree as *mut ai::TbBehaviorTree); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbGlobalConfig.as_ref() as *const common::TbGlobalConfig as *mut common::TbGlobalConfig); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbItem.as_ref() as *const item::TbItem as *mut item::TbItem); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbL10NDemo.as_ref() as *const l10n::TbL10NDemo as *mut l10n::TbL10NDemo); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbPatchDemo.as_ref() as *const l10n::TbPatchDemo as *mut l10n::TbPatchDemo); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestTag.as_ref() as *const tag::TbTestTag as *mut tag::TbTestTag); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbFullTypes.as_ref() as *const test::TbFullTypes as *mut test::TbFullTypes); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbSingleton.as_ref() as *const test::TbSingleton as *mut test::TbSingleton); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbNotIndexList.as_ref() as *const test::TbNotIndexList as *mut test::TbNotIndexList); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbMultiUnionIndexList.as_ref() as *const test::TbMultiUnionIndexList as *mut test::TbMultiUnionIndexList); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbMultiIndexList.as_ref() as *const test::TbMultiIndexList as *mut test::TbMultiIndexList); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDataFromMisc.as_ref() as *const test::TbDataFromMisc as *mut test::TbDataFromMisc); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbMultiRowRecord.as_ref() as *const test::TbMultiRowRecord as *mut test::TbMultiRowRecord); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestMultiColumn.as_ref() as *const test::TbTestMultiColumn as *mut test::TbTestMultiColumn); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbMultiRowTitle.as_ref() as *const test::TbMultiRowTitle as *mut test::TbMultiRowTitle); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestNull.as_ref() as *const test::TbTestNull as *mut test::TbTestNull); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDemoPrimitive.as_ref() as *const test::TbDemoPrimitive as *mut test::TbDemoPrimitive); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestString.as_ref() as *const test::TbTestString as *mut test::TbTestString); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDemoGroup.as_ref() as *const test::TbDemoGroup as *mut test::TbDemoGroup); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDemoGroup_C.as_ref() as *const test::TbDemoGroup_C as *mut test::TbDemoGroup_C); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDemoGroup_S.as_ref() as *const test::TbDemoGroup_S as *mut test::TbDemoGroup_S); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDemoGroup_E.as_ref() as *const test::TbDemoGroup_E as *mut test::TbDemoGroup_E); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestGlobal.as_ref() as *const test::TbTestGlobal as *mut test::TbTestGlobal); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestBeRef.as_ref() as *const test::TbTestBeRef as *mut test::TbTestBeRef); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestBeRef2.as_ref() as *const test::TbTestBeRef2 as *mut test::TbTestBeRef2); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestRef.as_ref() as *const test::TbTestRef as *mut test::TbTestRef); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestSize.as_ref() as *const test::TbTestSize as *mut test::TbTestSize); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestSet.as_ref() as *const test::TbTestSet as *mut test::TbTestSet); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestRange.as_ref() as *const test::TbTestRange as *mut test::TbTestRange); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDetectCsvEncoding.as_ref() as *const test::TbDetectCsvEncoding as *mut test::TbDetectCsvEncoding); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbItem2.as_ref() as *const test::TbItem2 as *mut test::TbItem2); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestIndex.as_ref() as *const test::TbTestIndex as *mut test::TbTestIndex); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestMap.as_ref() as *const test::TbTestMap as *mut test::TbTestMap); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbExcelFromJson.as_ref() as *const test::TbExcelFromJson as *mut test::TbExcelFromJson); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbCompositeJsonTable1.as_ref() as *const test::TbCompositeJsonTable1 as *mut test::TbCompositeJsonTable1); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbCompositeJsonTable2.as_ref() as *const test::TbCompositeJsonTable2 as *mut test::TbCompositeJsonTable2); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbCompositeJsonTable3.as_ref() as *const test::TbCompositeJsonTable3 as *mut test::TbCompositeJsonTable3); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbExcelFromJsonMultiRow.as_ref() as *const test::TbExcelFromJsonMultiRow as *mut test::TbExcelFromJsonMultiRow); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestScriptableObject.as_ref() as *const test::TbTestScriptableObject as *mut test::TbTestScriptableObject); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbPath.as_ref() as *const test::TbPath as *mut test::TbPath); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestFieldAlias.as_ref() as *const test::TbTestFieldAlias as *mut test::TbTestFieldAlias); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestFieldVariant.as_ref() as *const test::TbTestFieldVariant as *mut test::TbTestFieldVariant); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestFieldVariant2.as_ref() as *const test::TbTestFieldVariant2 as *mut test::TbTestFieldVariant2); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestMapper.as_ref() as *const test::TbTestMapper as *mut test::TbTestMapper); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbDefineFromExcel2.as_ref() as *const test::TbDefineFromExcel2 as *mut test::TbDefineFromExcel2); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbAutoImport1.as_ref() as *const TbAutoImport1 as *mut TbAutoImport1); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbAutoImport2.as_ref() as *const test::TbAutoImport2 as *mut test::TbAutoImport2); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
        let mut b = Box::from_raw(self.TbTestFormat.as_ref() as *const test::TbTestFormat as *mut test::TbTestFormat); b.as_mut().resolve_ref(self); let _ = Box::into_raw(b);
    }
}
pub mod ai;
pub mod common;
pub mod item;
pub mod l10n;
pub mod tag;
pub mod test;
pub mod test2;

use luban_lib::*;

#[derive(Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum AudioType {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
}

impl From<i32> for AudioType {
    fn from(value: i32) -> Self {
        match value {
            0 => AudioType::UNKNOWN,
            1 => AudioType::ACC,
            2 => AudioType::AIFF,
            _ => panic!("Invalid value for AudioType:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct AutoImport1 {
    /// 这是id
    pub id: i32,
    /// 字段x1
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub x8: i32,
    pub x10: String,
    pub x13: test::DemoEnum,
    pub x13_2: test::DemoFlag,
    pub x14: test::DemoDynamic,
    pub x15: test::Shape,
    pub v2: crate::Vec2,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<test::DemoE2>,
    pub k10: Vec<crate::Vec3>,
    pub k11: Vec<crate::Vec4>,
    pub v11: Option<crate::Vec3>,
}

impl AutoImport1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<AutoImport1, LubanError> {
        let id = buf.read_int();
        let x1 = buf.read_bool();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x8 = buf.read_int();
        let x10 = buf.read_string();
        let x13 = Into::<test::DemoEnum>::into(buf.read_int());
        let x13_2 = test::DemoFlag::from_bits_truncate(buf.read_uint());
        let x14 = test::DemoDynamic::new(&mut buf)?;
        let x15 = test::Shape::new(&mut buf)?;
        let v2 = vec2::new(&mut buf)?.into();
        let t1 = buf.read_ulong();
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(test::DemoE2::new(&mut buf)?); } _e0 };
        let k10 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(vec3::new(&mut buf)?.into()); } _e0 };
        let k11 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(vec4::new(&mut buf)?.into()); } _e0 };
        let mut v11 = if buf.read_bool() { Some(vec3::new(&mut buf)?.into()) } else { None };
        
        Ok(AutoImport1 { id, x1, x5, x6, x8, x10, x13, x13_2, x14, x15, v2, t1, k1, k2, k8, k9, k10, k11, v11, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x14.resolve_ref(tables);
        self.x15.resolve_ref(tables);
    }

    pub const __ID__: i32 = -2092142499;
}

#[derive(Debug)]
pub struct vec2 {
    pub x: f32,
    pub y: f32,
}

impl vec2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vec2, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        
        Ok(vec2 { x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 3615518;
}

#[derive(Debug)]
pub struct vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl vec3{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vec3, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        let z = buf.read_float();
        
        Ok(vec3 { x, y, z, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 3615519;
}

#[derive(Debug)]
pub struct vec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}

impl vec4{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<vec4, LubanError> {
        let x = buf.read_float();
        let y = buf.read_float();
        let z = buf.read_float();
        let w = buf.read_float();
        
        Ok(vec4 { x, y, z, w, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 3615520;
}


#[derive(Debug)]
pub struct TbAutoImport1 {
    pub data_list: Vec<std::sync::Arc<AutoImport1>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<AutoImport1>>,
}

impl TbAutoImport1 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbAutoImport1>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<AutoImport1>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<AutoImport1>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(AutoImport1::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbAutoImport1 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<AutoImport1>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const AutoImport1 as *mut AutoImport1); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbAutoImport1 {
    type Output = std::sync::Arc<AutoImport1>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


