
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

pub mod login;

use super::*;
use luban_lib::*;

bitflags::bitflags! {    
    #[derive(Debug, Hash, Eq, PartialEq)]
    pub struct AccessFlag : u32 {
        const WRITE = 1;
        const READ = 2;
        const TRUNCATE = 4;
        const NEW = 8;
        const READ_WRITE = 3;
    }
}
#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum AudioType2 {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
}

impl From<i32> for AudioType2 {
    fn from(value: i32) -> Self {
        match value {
            0 => AudioType2::UNKNOWN,
            1 => AudioType2::ACC,
            2 => AudioType2::AIFF,
            _ => panic!("Invalid value for AudioType2:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum DemoEnum {
    NONE = 0,
    ///aa
    A = 1,
    ///bb
    B = 2,
    ///cc
    C = 4,
    ///dd
    D = 5,
    Any = 6,
}

impl From<i32> for DemoEnum {
    fn from(value: i32) -> Self {
        match value {
            0 => DemoEnum::NONE,
            1 => DemoEnum::A,
            2 => DemoEnum::B,
            4 => DemoEnum::C,
            5 => DemoEnum::D,
            6 => DemoEnum::Any,
            _ => panic!("Invalid value for DemoEnum:{}", value),
        }
    }
}

bitflags::bitflags! {    
    #[derive(Debug, Hash, Eq, PartialEq)]
    pub struct DemoFlag : u32 {
        const A = 1;
        const B = 2;
        const C = 4;
        const D = 8;
    }
}
#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ETestEmptyEnum {
    None
}

impl From<i32> for ETestEmptyEnum {
    fn from(value: i32) -> Self {
        match value {
            _ => panic!("Invalid value for ETestEmptyEnum:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ETestEmptyEnum2 {
    SMALL_THAN_256 = 255,
    X_256 = 256,
    X_257 = 257,
}

impl From<i32> for ETestEmptyEnum2 {
    fn from(value: i32) -> Self {
        match value {
            255 => ETestEmptyEnum2::SMALL_THAN_256,
            256 => ETestEmptyEnum2::X_256,
            257 => ETestEmptyEnum2::X_257,
            _ => panic!("Invalid value for ETestEmptyEnum2:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ETestQuality {
    ///最高品质
    A = 1,
    ///黑色的
    B = 2,
    ///蓝色的
    C = 3,
    ///最差品质
    D = 4,
}

impl From<i32> for ETestQuality {
    fn from(value: i32) -> Self {
        match value {
            1 => ETestQuality::A,
            2 => ETestQuality::B,
            3 => ETestQuality::C,
            4 => ETestQuality::D,
            _ => panic!("Invalid value for ETestQuality:{}", value),
        }
    }
}

#[derive(Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ETestUeType {
    ///白
    WHITE = 0,
    BLACK = 1,
}

impl From<i32> for ETestUeType {
    fn from(value: i32) -> Self {
        match value {
            0 => ETestUeType::WHITE,
            1 => ETestUeType::BLACK,
            _ => panic!("Invalid value for ETestUeType:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct AutoImport2 {
    /// 这是id
    pub id: i32,
    /// 字段x1
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub x8: i32,
    pub x10: String,
    pub x13: crate::test::DemoEnum,
    pub x13_2: crate::test::DemoFlag,
    pub x14: crate::test::DemoDynamic,
    pub x15: crate::test::Shape,
    pub v2: crate::vec2,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k10: Vec<crate::vec3>,
    pub k11: Vec<crate::vec4>,
    pub v11: Option<crate::vec3>,
}

impl AutoImport2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<AutoImport2, LubanError> {
        let id = buf.read_int();
        let x1 = buf.read_bool();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x8 = buf.read_int();
        let x10 = buf.read_string();
        let x13 = buf.read_int().into();
        let x13_2 = crate::test::DemoFlag::from_bits_truncate(buf.read_uint());
        let x14 = crate::test::DemoDynamic::new(&mut buf)?;
        let x15 = crate::test::Shape::new(&mut buf)?;
        let v2 = crate::vec2::new(&mut buf)?;
        let t1 = buf.read_ulong();
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoE2::new(&mut buf)?); } _e0 };
        let k10 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec3::new(&mut buf)?); } _e0 };
        let k11 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec4::new(&mut buf)?); } _e0 };
        let mut v11 = if buf.read_bool() { Some(crate::vec3::new(&mut buf)?) } else { None };
        
        Ok(AutoImport2 { id, x1, x5, x6, x8, x10, x13, x13_2, x14, x15, v2, t1, k1, k2, k8, k9, k10, k11, v11, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x14.resolve_ref(tables);
        self.x15.resolve_ref(tables);
    }

    pub const __ID__: i32 = 417472770;
}

#[derive(Debug)]
pub struct CompactString {
    pub id: i32,
    pub s2: String,
    pub s3: String,
}

impl CompactString{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<CompactString, LubanError> {
        let id = buf.read_int();
        let s2 = buf.read_string();
        let s3 = buf.read_string();
        
        Ok(CompactString { id, s2, s3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1968089240;
}

#[derive(Debug)]
pub struct CompositeJsonTable1 {
    pub id: i32,
    pub x: String,
}

impl CompositeJsonTable1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<CompositeJsonTable1, LubanError> {
        let id = buf.read_int();
        let x = buf.read_string();
        
        Ok(CompositeJsonTable1 { id, x, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1566207894;
}

#[derive(Debug)]
pub struct CompositeJsonTable2 {
    pub id: i32,
    pub y: i32,
}

impl CompositeJsonTable2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<CompositeJsonTable2, LubanError> {
        let id = buf.read_int();
        let y = buf.read_int();
        
        Ok(CompositeJsonTable2 { id, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1566207895;
}

#[derive(Debug)]
pub struct CompositeJsonTable3 {
    pub a: i32,
    pub b: i32,
}

impl CompositeJsonTable3{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<CompositeJsonTable3, LubanError> {
        let a = buf.read_int();
        let b = buf.read_int();
        
        Ok(CompositeJsonTable3 { a, b, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1566207896;
}

#[derive(Debug)]
pub struct DateTimeRange {
    pub start_time: u64,
    pub end_time: u64,
}

impl DateTimeRange{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DateTimeRange, LubanError> {
        let start_time = buf.read_ulong();
        let end_time = buf.read_ulong();
        
        Ok(DateTimeRange { start_time, end_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 495315430;
}

#[derive(Debug)]
pub struct DefineFromExcel2 {
    /// 这是id
    pub id: i32,
    /// 字段x1
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub x8: i32,
    pub x10: String,
    pub x13: crate::test::DemoEnum,
    pub x13_2: crate::test::DemoFlag,
    pub x13_3: crate::test::DemoFlag,
    pub x14: crate::test::DemoDynamic,
    pub x15: crate::test::Shape,
    pub v2: crate::vec2,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k10: Vec<crate::vec3>,
    pub k11: Vec<crate::vec4>,
    pub v11: Option<crate::vec3>,
}

impl DefineFromExcel2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DefineFromExcel2, LubanError> {
        let id = buf.read_int();
        let x1 = buf.read_bool();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x8 = buf.read_int();
        let x10 = buf.read_string();
        let x13 = buf.read_int().into();
        let x13_2 = crate::test::DemoFlag::from_bits_truncate(buf.read_uint());
        let x13_3 = crate::test::DemoFlag::from_bits_truncate(buf.read_uint());
        let x14 = crate::test::DemoDynamic::new(&mut buf)?;
        let x15 = crate::test::Shape::new(&mut buf)?;
        let v2 = crate::vec2::new(&mut buf)?;
        let t1 = buf.read_ulong();
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoE2::new(&mut buf)?); } _e0 };
        let k10 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec3::new(&mut buf)?); } _e0 };
        let k11 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec4::new(&mut buf)?); } _e0 };
        let mut v11 = if buf.read_bool() { Some(crate::vec3::new(&mut buf)?) } else { None };
        
        Ok(DefineFromExcel2 { id, x1, x5, x6, x8, x10, x13, x13_2, x13_3, x14, x15, v2, t1, k1, k2, k8, k9, k10, k11, v11, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x14.resolve_ref(tables);
        self.x15.resolve_ref(tables);
    }

    pub const __ID__: i32 = 688816828;
}

#[derive(Debug)]
pub enum DemoDynamic {
    DemoD2(std::sync::Arc<crate::test::DemoD2>),
    DemoE1(std::sync::Arc<crate::test::DemoE1>),
    RoleInfo(std::sync::Arc<crate::test::login::RoleInfo>),
    DemoD5(std::sync::Arc<crate::test::DemoD5>),
}

impl DemoDynamic {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::DemoD2::__ID__ => Ok(Self::DemoD2(std::sync::Arc::new(crate::test::DemoD2::new(buf)?))),
            crate::test::DemoE1::__ID__ => Ok(Self::DemoE1(std::sync::Arc::new(crate::test::DemoE1::new(buf)?))),
            crate::test::login::RoleInfo::__ID__ => Ok(Self::RoleInfo(std::sync::Arc::new(crate::test::login::RoleInfo::new(buf)?))),
            crate::test::DemoD5::__ID__ => Ok(Self::DemoD5(std::sync::Arc::new(crate::test::DemoD5::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoDynamic:{}", type_id)))
        }
    }
    
    pub fn get_x1(&self) -> &i32 {
        match self {
            Self::DemoD2(x) => { &x.x1 }
            Self::DemoE1(x) => { &x.x1 }
            Self::RoleInfo(x) => { &x.x1 }
            Self::DemoD5(x) => { &x.x1 }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::DemoD2(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoD2 as *mut crate::test::DemoD2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DemoE1(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoE1 as *mut crate::test::DemoE1); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::RoleInfo(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::login::RoleInfo as *mut crate::test::login::RoleInfo); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DemoD5(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoD5 as *mut crate::test::DemoD5); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct DemoD2 {
    pub x1: i32,
    pub x2: i32,
}

impl DemoD2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoD2, LubanError> {
        let x1 = buf.read_int();
        let x2 = buf.read_int();
        
        Ok(DemoD2 { x1, x2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -2138341747;
}

#[derive(Debug)]
pub enum DemoD3 {
    DemoE1(std::sync::Arc<crate::test::DemoE1>),
    RoleInfo(std::sync::Arc<crate::test::login::RoleInfo>),
}

impl DemoD3 {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::DemoE1::__ID__ => Ok(Self::DemoE1(std::sync::Arc::new(crate::test::DemoE1::new(buf)?))),
            crate::test::login::RoleInfo::__ID__ => Ok(Self::RoleInfo(std::sync::Arc::new(crate::test::login::RoleInfo::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoD3:{}", type_id)))
        }
    }
    
    pub fn get_x1(&self) -> &i32 {
        match self {
            Self::DemoE1(x) => { &x.x1 }
            Self::RoleInfo(x) => { &x.x1 }
        }
    }    
    
    pub fn get_x3(&self) -> &i32 {
        match self {
            Self::DemoE1(x) => { &x.x3 }
            Self::RoleInfo(x) => { &x.x3 }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::DemoE1(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoE1 as *mut crate::test::DemoE1); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::RoleInfo(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::login::RoleInfo as *mut crate::test::login::RoleInfo); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct DemoE1 {
    pub x1: i32,
    pub x3: i32,
    pub x4: i32,
}

impl DemoE1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoE1, LubanError> {
        let x1 = buf.read_int();
        let x3 = buf.read_int();
        let x4 = buf.read_int();
        
        Ok(DemoE1 { x1, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -2138341717;
}

#[derive(Debug)]
pub struct DemoD5 {
    pub x1: i32,
    pub time: crate::test::DateTimeRange,
}

impl DemoD5{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoD5, LubanError> {
        let x1 = buf.read_int();
        let time = crate::test::DateTimeRange::new(&mut buf)?;
        
        Ok(DemoD5 { x1, time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.time.resolve_ref(tables);
    }

    pub const __ID__: i32 = -2138341744;
}

#[derive(Debug)]
pub struct DemoE2 {
    pub y1: Option<i32>,
    pub y2: bool,
}

impl DemoE2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoE2, LubanError> {
        let mut y1 = if buf.read_bool() { Some(buf.read_int()) } else { None };
        let y2 = buf.read_bool();
        
        Ok(DemoE2 { y1, y2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -2138341716;
}

#[derive(Debug)]
pub struct DemoExplicitType {
    pub x1: u8,
    pub x2: i16,
    pub x3: i32,
    pub x4: i64,
    pub x5: f32,
    pub x6: f64,
    pub x7: i64,
}

impl DemoExplicitType{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoExplicitType, LubanError> {
        let x1 = buf.read_byte();
        let x2 = buf.read_short();
        let x3 = buf.read_int();
        let x4 = buf.read_long();
        let x5 = buf.read_float();
        let x6 = buf.read_double();
        let x7 = buf.read_long();
        
        Ok(DemoExplicitType { x1, x2, x3, x4, x5, x6, x7, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 370351885;
}

#[derive(Debug)]
pub struct DemoGroup {
    pub id: i32,
    pub x1: i32,
    pub x1_ref: Option<std::sync::Arc<crate::test::DemoGroup>>,
    pub x2: i32,
    pub x2_ref: Option<std::sync::Arc<crate::test::DemoGroup>>,
    pub x3: i32,
    pub x3_ref: Option<std::sync::Arc<crate::test::DemoGroup>>,
    pub x4: i32,
    pub x5: crate::test::InnerGroup,
}

impl DemoGroup{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoGroup, LubanError> {
        let id = buf.read_int();
        let x1 = buf.read_int();
        let x1_ref = None;
        let x2 = buf.read_int();
        let x2_ref = None;
        let x3 = buf.read_int();
        let x3_ref = None;
        let x4 = buf.read_int();
        let x5 = crate::test::InnerGroup::new(&mut buf)?;
        
        Ok(DemoGroup { id, x1, x1_ref, x2, x2_ref, x3, x3_ref, x4, x5, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x1_ref = tables.TbDemoGroup_C.get(&self.x1);
        self.x2_ref = tables.TbDemoGroup_S.get(&self.x2);
        self.x3_ref = tables.TbDemoGroup_E.get(&self.x3);
        self.x5.resolve_ref(tables);
    }

    pub const __ID__: i32 = -379263008;
}

#[derive(Debug)]
pub struct DemoPrimitiveTypesTable {
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x4: i32,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub s1: String,
    pub s2: String,
    pub v2: crate::vec2,
    pub v3: crate::vec3,
    pub v4: crate::vec4,
    pub t1: u64,
}

impl DemoPrimitiveTypesTable{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoPrimitiveTypesTable, LubanError> {
        let x1 = buf.read_bool();
        let x2 = buf.read_byte();
        let x3 = buf.read_short();
        let x4 = buf.read_int();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x7 = buf.read_double();
        let s1 = buf.read_string();
        let s2 = buf.read_string();
        let v2 = crate::vec2::new(&mut buf)?;
        let v3 = crate::vec3::new(&mut buf)?;
        let v4 = crate::vec4::new(&mut buf)?;
        let t1 = buf.read_ulong();
        
        Ok(DemoPrimitiveTypesTable { x1, x2, x3, x4, x5, x6, x7, s1, s2, v2, v3, v4, t1, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -370934083;
}

#[derive(Debug)]
pub struct DemoSingletonType {
    pub id: i32,
    pub name: String,
    pub date: crate::test::DemoDynamic,
}

impl DemoSingletonType{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoSingletonType, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let date = crate::test::DemoDynamic::new(&mut buf)?;
        
        Ok(DemoSingletonType { id, name, date, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.date.resolve_ref(tables);
    }

    pub const __ID__: i32 = 539196998;
}

#[derive(Debug)]
pub struct DemoType1 {
    pub x1: i32,
}

impl DemoType1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoType1, LubanError> {
        let x1 = buf.read_int();
        
        Ok(DemoType1 { x1, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -367048296;
}

#[derive(Debug)]
pub struct DemoType2 {
    pub x4: i32,
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub x8_0: i16,
    pub x8: i32,
    pub x9: i64,
    pub x10: String,
    pub x12: crate::test::DemoType1,
    pub x13: crate::test::DemoEnum,
    pub x14: crate::test::DemoDynamic,
    pub s1: String,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k5: std::collections::HashSet<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k8_ref: Option<std::sync::Arc<std::collections::HashMap<i32, Option<std::sync::Arc<crate::test::DemoType2>>>>>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k15: Vec<crate::test::DemoDynamic>,
}

impl DemoType2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DemoType2, LubanError> {
        let x4 = buf.read_int();
        let x1 = buf.read_bool();
        let x2 = buf.read_byte();
        let x3 = buf.read_short();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x7 = buf.read_double();
        let x8_0 = buf.read_short();
        let x8 = buf.read_int();
        let x9 = buf.read_long();
        let x10 = buf.read_string();
        let x12 = crate::test::DemoType1::new(&mut buf)?;
        let x13 = buf.read_int().into();
        let x14 = crate::test::DemoDynamic::new(&mut buf)?;
        let s1 = buf.read_string();
        let t1 = buf.read_ulong();
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k5 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k8_ref = None;
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoE2::new(&mut buf)?); } _e0 };
        let k15 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoDynamic::new(&mut buf)?); } _e0 };
        
        Ok(DemoType2 { x4, x1, x2, x3, x5, x6, x7, x8_0, x8, x9, x10, x12, x13, x14, s1, t1, k1, k2, k5, k8, k8_ref, k9, k15, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x12.resolve_ref(tables);
        self.x14.resolve_ref(tables);
        self.k8_ref = Some(std::sync::Arc::new(self.k8.iter().map(|x| (x.0.clone(), tables.TbFullTypes.get(x.1))).collect()));
        self.k15.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -367048295;
}

#[derive(Debug)]
pub struct DetectEncoding {
    pub id: i32,
    pub name: String,
}

impl DetectEncoding{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<DetectEncoding, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        
        Ok(DetectEncoding { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1154609646;
}

#[derive(Debug)]
pub struct ExcelFromJson {
    pub x4: i32,
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub s1: String,
    pub s2: String,
    pub t1: u64,
    pub x12: crate::test::DemoType1,
    pub x13: crate::test::DemoEnum,
    pub x14: crate::test::DemoDynamic,
    pub k1: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
    pub k15: Vec<crate::test::DemoDynamic>,
}

impl ExcelFromJson{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ExcelFromJson, LubanError> {
        let x4 = buf.read_int();
        let x1 = buf.read_bool();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let s1 = buf.read_string();
        let s2 = buf.read_string();
        let t1 = buf.read_ulong();
        let x12 = crate::test::DemoType1::new(&mut buf)?;
        let x13 = buf.read_int().into();
        let x14 = crate::test::DemoDynamic::new(&mut buf)?;
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoE2::new(&mut buf)?); } _e0 };
        let k15 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoDynamic::new(&mut buf)?); } _e0 };
        
        Ok(ExcelFromJson { x4, x1, x5, x6, s1, s2, t1, x12, x13, x14, k1, k8, k9, k15, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x12.resolve_ref(tables);
        self.x14.resolve_ref(tables);
        self.k15.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = -1485706483;
}

#[derive(Debug)]
pub struct ExcelFromJsonMultiRow {
    pub id: i32,
    pub x: i32,
    pub items: Vec<crate::test::TestRow>,
}

impl ExcelFromJsonMultiRow{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<ExcelFromJsonMultiRow, LubanError> {
        let id = buf.read_int();
        let x = buf.read_int();
        let items = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::TestRow::new(&mut buf)?); } _e0 };
        
        Ok(ExcelFromJsonMultiRow { id, x, items, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.items.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 715335694;
}

#[derive(Debug)]
pub struct Foo {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
}

impl Foo{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Foo, LubanError> {
        let y1 = buf.read_int();
        let y2 = buf.read_int();
        let y3 = buf.read_int();
        
        Ok(Foo { y1, y2, y3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1147950774;
}

#[derive(Debug)]
pub struct H1 {
    pub y2: crate::test::H2,
    pub y3: i32,
}

impl H1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<H1, LubanError> {
        let y2 = crate::test::H2::new(&mut buf)?;
        let y3 = buf.read_int();
        
        Ok(H1 { y2, y3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.y2.resolve_ref(tables);
    }

    pub const __ID__: i32 = -1422503995;
}

#[derive(Debug)]
pub struct H2 {
    pub z2: i32,
    pub z3: i32,
}

impl H2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<H2, LubanError> {
        let z2 = buf.read_int();
        let z3 = buf.read_int();
        
        Ok(H2 { z2, z3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1422503994;
}

#[derive(Debug)]
pub struct InnerGroup {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
    pub y4: i32,
}

impl InnerGroup{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<InnerGroup, LubanError> {
        let y1 = buf.read_int();
        let y2 = buf.read_int();
        let y3 = buf.read_int();
        let y4 = buf.read_int();
        
        Ok(InnerGroup { y1, y2, y3, y4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -587873083;
}

#[derive(Debug)]
pub enum ItemBase {
    Item(std::sync::Arc<crate::test::Item>),
    Equipment(std::sync::Arc<crate::test::Equipment>),
    Decorator(std::sync::Arc<crate::test::Decorator>),
}

impl ItemBase {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::Item::__ID__ => Ok(Self::Item(std::sync::Arc::new(crate::test::Item::new(buf)?))),
            crate::test::Equipment::__ID__ => Ok(Self::Equipment(std::sync::Arc::new(crate::test::Equipment::new(buf)?))),
            crate::test::Decorator::__ID__ => Ok(Self::Decorator(std::sync::Arc::new(crate::test::Decorator::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for ItemBase:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::Item(x) => { &x.id }
            Self::Equipment(x) => { &x.id }
            Self::Decorator(x) => { &x.id }
        }
    }    
    
    pub fn get_name(&self) -> &String {
        match self {
            Self::Item(x) => { &x.name }
            Self::Equipment(x) => { &x.name }
            Self::Decorator(x) => { &x.name }
        }
    }    
    
    pub fn get_desc(&self) -> &String {
        match self {
            Self::Item(x) => { &x.desc }
            Self::Equipment(x) => { &x.desc }
            Self::Decorator(x) => { &x.desc }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Item(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::Item as *mut crate::test::Item); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Equipment(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::Equipment as *mut crate::test::Equipment); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Decorator(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::Decorator as *mut crate::test::Decorator); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct Decorator {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub duration: i32,
}

impl Decorator{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Decorator, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let duration = buf.read_int();
        
        Ok(Decorator { id, name, desc, duration, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -625155649;
}

#[derive(Debug)]
pub struct Equipment {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub attr: crate::test::DemoEnum,
    pub value: i32,
}

impl Equipment{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Equipment, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let attr = buf.read_int().into();
        let value = buf.read_int();
        
        Ok(Equipment { id, name, desc, attr, value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -76837102;
}

#[derive(Debug)]
pub struct Item {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub num: i32,
    pub price: i32,
}

impl Item{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Item, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let desc = buf.read_string();
        let num = buf.read_int();
        let price = buf.read_int();
        
        Ok(Item { id, name, desc, num, price, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1226641649;
}

#[derive(Debug)]
pub struct MultiIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiIndexList{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MultiIndexList, LubanError> {
        let id1 = buf.read_int();
        let id2 = buf.read_long();
        let id3 = buf.read_string();
        let num = buf.read_int();
        let desc = buf.read_string();
        
        Ok(MultiIndexList { id1, id2, id3, num, desc, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 2016237651;
}

#[derive(Debug)]
pub struct MultiRowRecord {
    pub id: i32,
    pub name: String,
    pub one_rows: Vec<crate::test::MultiRowType1>,
    pub multi_rows1: Vec<crate::test::MultiRowType1>,
    pub multi_rows2: Vec<crate::test::MultiRowType1>,
    pub multi_rows4: std::collections::HashMap<i32, crate::test::MultiRowType2>,
    pub multi_rows5: Vec<crate::test::MultiRowType3>,
    pub multi_rows6: std::collections::HashMap<i32, crate::test::MultiRowType2>,
    pub multi_rows7: std::collections::HashMap<i32, i32>,
}

impl MultiRowRecord{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MultiRowRecord, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let one_rows = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        let multi_rows1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        let multi_rows2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        let multi_rows4 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = crate::test::MultiRowType2::new(&mut buf)?; _e0.insert(_k0, _v0);} _e0 };
        let multi_rows5 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType3::new(&mut buf)?); } _e0 };
        let multi_rows6 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = crate::test::MultiRowType2::new(&mut buf)?; _e0.insert(_k0, _v0);} _e0 };
        let multi_rows7 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        
        Ok(MultiRowRecord { id, name, one_rows, multi_rows1, multi_rows2, multi_rows4, multi_rows5, multi_rows6, multi_rows7, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.one_rows.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows1.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows2.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows4.values_mut().for_each(|x| { x.resolve_ref(tables) });
        self.multi_rows5.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows6.values_mut().for_each(|x| { x.resolve_ref(tables) });
    }

    pub const __ID__: i32 = -501249394;
}

#[derive(Debug)]
pub struct MultiRowTitle {
    pub id: i32,
    pub name: String,
    pub x1: crate::test::H1,
    pub x2_0: Option<crate::test::H2>,
    pub x2: Vec<crate::test::H2>,
    pub x3: Vec<crate::test::H2>,
    pub x4: Vec<crate::test::H2>,
}

impl MultiRowTitle{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MultiRowTitle, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        let x1 = crate::test::H1::new(&mut buf)?;
        let mut x2_0 = if buf.read_bool() { Some(crate::test::H2::new(&mut buf)?) } else { None };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::H2::new(&mut buf)?); } _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::H2::new(&mut buf)?); } _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::H2::new(&mut buf)?); } _e0 };
        
        Ok(MultiRowTitle { id, name, x1, x2_0, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x1.resolve_ref(tables);
        if let Some(x) = &mut self.x2_0 { x.resolve_ref(tables); }
        self.x2.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.x3.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.x4.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 540002427;
}

#[derive(Debug)]
pub struct MultiRowType1 {
    pub id: i32,
    pub x: i32,
}

impl MultiRowType1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MultiRowType1, LubanError> {
        let id = buf.read_int();
        let x = buf.read_int();
        
        Ok(MultiRowType1 { id, x, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 540474970;
}

#[derive(Debug)]
pub struct MultiRowType2 {
    pub id: i32,
    pub x: i32,
    pub y: f32,
}

impl MultiRowType2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MultiRowType2, LubanError> {
        let id = buf.read_int();
        let x = buf.read_int();
        let y = buf.read_float();
        
        Ok(MultiRowType2 { id, x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 540474971;
}

#[derive(Debug)]
pub struct MultiRowType3 {
    pub id: i32,
    pub items: Vec<crate::test::MultiRowType1>,
}

impl MultiRowType3{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MultiRowType3, LubanError> {
        let id = buf.read_int();
        let items = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::MultiRowType1::new(&mut buf)?); } _e0 };
        
        Ok(MultiRowType3 { id, items, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.items.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 540474972;
}

#[derive(Debug)]
pub struct MultiUnionIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiUnionIndexList{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<MultiUnionIndexList, LubanError> {
        let id1 = buf.read_int();
        let id2 = buf.read_long();
        let id3 = buf.read_string();
        let num = buf.read_int();
        let desc = buf.read_string();
        
        Ok(MultiUnionIndexList { id1, id2, id3, num, desc, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1966847134;
}

#[derive(Debug)]
pub struct NotIndexList {
    pub x: i32,
    pub y: i32,
}

impl NotIndexList{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<NotIndexList, LubanError> {
        let x = buf.read_int();
        let y = buf.read_int();
        
        Ok(NotIndexList { x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -50446599;
}

#[derive(Debug)]
pub struct Path {
    pub id: i32,
    pub res: String,
}

impl Path{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Path, LubanError> {
        let id = buf.read_int();
        let res = buf.read_string();
        
        Ok(Path { id, res, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1226450911;
}

#[derive(Debug)]
pub enum RefDynamicBase {
    RefBean(std::sync::Arc<crate::test::RefBean>),
}

impl RefDynamicBase {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::RefBean::__ID__ => Ok(Self::RefBean(std::sync::Arc::new(crate::test::RefBean::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for RefDynamicBase:{}", type_id)))
        }
    }
    
    pub fn get_x(&self) -> &i32 {
        match self {
            Self::RefBean(x) => { &x.x }
        }
    }    
        
    pub fn get_x_ref(&self) -> &Option<std::sync::Arc<crate::test::TestBeRef>> {
        match self {
            Self::RefBean(x) => { &x.x_ref }
        }        
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::RefBean(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::RefBean as *mut crate::test::RefBean); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct RefBean {
    pub x: i32,
    pub x_ref: Option<std::sync::Arc<crate::test::TestBeRef>>,
    pub arr: Vec<i32>,
    pub arr_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
}

impl RefBean{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<RefBean, LubanError> {
        let x = buf.read_int();
        let x_ref = None;
        let arr = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let arr_ref = None;
        
        Ok(RefBean { x, x_ref, arr, arr_ref, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x_ref = tables.TbTestBeRef.get(&self.x);
        self.arr_ref = Some(std::sync::Arc::new(self.arr.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
    }

    pub const __ID__: i32 = 1963260263;
}

#[derive(Debug)]
pub struct SepBean1 {
    pub a: i32,
    pub b: i32,
    pub c: String,
}

impl SepBean1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<SepBean1, LubanError> {
        let a = buf.read_int();
        let b = buf.read_int();
        let c = buf.read_string();
        
        Ok(SepBean1 { a, b, c, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1534339393;
}

#[derive(Debug)]
pub struct SepVector {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

impl SepVector{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<SepVector, LubanError> {
        let x = buf.read_int();
        let y = buf.read_int();
        let z = buf.read_int();
        
        Ok(SepVector { x, y, z, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 252769477;
}

#[derive(Debug)]
pub enum Shape {
    Circle(std::sync::Arc<crate::test::Circle>),
    Rectangle(std::sync::Arc<crate::test2::Rectangle>),
}

impl Shape {
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Self, LubanError> {
        let type_id = buf.read_int();
        match type_id {
            crate::test::Circle::__ID__ => Ok(Self::Circle(std::sync::Arc::new(crate::test::Circle::new(buf)?))),
            crate::test2::Rectangle::__ID__ => Ok(Self::Rectangle(std::sync::Arc::new(crate::test2::Rectangle::new(buf)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Shape:{}", type_id)))
        }
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Circle(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test::Circle as *mut crate::test::Circle); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Rectangle(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::test2::Rectangle as *mut crate::test2::Rectangle); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct Circle {
    /// 半径
    pub radius: f32,
}

impl Circle{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Circle, LubanError> {
        let radius = buf.read_float();
        
        Ok(Circle { radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 2131829196;
}

#[derive(Debug)]
pub struct Test3 {
    pub x: i32,
    pub y: i32,
}

impl Test3{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<Test3, LubanError> {
        let x = buf.read_int();
        let y = buf.read_int();
        
        Ok(Test3 { x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 638540133;
}

#[derive(Debug)]
pub struct TestBeRef {
    pub id: i32,
    pub count: i32,
}

impl TestBeRef{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestBeRef, LubanError> {
        let id = buf.read_int();
        let count = buf.read_int();
        
        Ok(TestBeRef { id, count, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1934403938;
}

#[derive(Debug)]
pub struct TestExcelBean1 {
    /// 最高品质
    pub x1: i32,
    /// 黑色的
    pub x2: String,
    /// 蓝色的
    pub x3: i32,
    /// 最差品质
    pub x4: f32,
}

impl TestExcelBean1{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestExcelBean1, LubanError> {
        let x1 = buf.read_int();
        let x2 = buf.read_string();
        let x3 = buf.read_int();
        let x4 = buf.read_float();
        
        Ok(TestExcelBean1 { x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1738345160;
}

#[derive(Debug)]
pub struct TestExcelBean2 {
    /// 最高品质
    pub y1: i32,
    /// 黑色的
    pub y2: String,
    /// 蓝色的
    pub y3: f32,
}

impl TestExcelBean2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestExcelBean2, LubanError> {
        let y1 = buf.read_int();
        let y2 = buf.read_string();
        let y3 = buf.read_float();
        
        Ok(TestExcelBean2 { y1, y2, y3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1738345159;
}

#[derive(Debug)]
pub struct TestFieldAlias {
    pub id: i32,
    pub name: String,
}

impl TestFieldAlias{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestFieldAlias, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        
        Ok(TestFieldAlias { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 285625508;
}

#[derive(Debug)]
pub struct TestFieldVariant {
    pub id: i32,
    pub name: String,
}

impl TestFieldVariant{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestFieldVariant, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        
        Ok(TestFieldVariant { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 759529945;
}

#[derive(Debug)]
pub struct TestFieldVariant2 {
    pub id: i32,
    pub name: String,
}

impl TestFieldVariant2{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestFieldVariant2, LubanError> {
        let id = buf.read_int();
        let name = buf.read_string();
        
        Ok(TestFieldVariant2 { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 2070591865;
}

#[derive(Debug)]
pub struct TestFormat {
    pub id: i32,
    pub a1: Vec<i32>,
    pub a2: Vec<i32>,
    pub a3: Vec<i32>,
    pub a4: Vec<i32>,
    pub b1: Vec<i32>,
    pub b2: Vec<i32>,
    pub b3: Vec<i32>,
    pub b4: Vec<i32>,
    pub c1: std::collections::HashSet<i32>,
    pub c2: std::collections::HashSet<i32>,
    pub c3: std::collections::HashSet<i32>,
    pub c4: std::collections::HashSet<i32>,
    pub m1: std::collections::HashMap<i32, i32>,
    pub m2: std::collections::HashMap<i32, i32>,
    pub m3: std::collections::HashMap<i32, i32>,
    pub m4: std::collections::HashMap<i32, i32>,
    pub v31: crate::vec3,
    pub v32: crate::vec3,
    pub v33: crate::vec3,
    pub v34: crate::vec3,
    pub v41: Vec<crate::vec3>,
    pub v42: Vec<crate::vec3>,
    pub v43: Vec<crate::vec3>,
    pub v44: Vec<crate::vec3>,
}

impl TestFormat{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestFormat, LubanError> {
        let id = buf.read_int();
        let a1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let a2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let a3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let a4 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b4 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let c1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let c2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let c3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let c4 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let m1 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let m2 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let m3 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let m4 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let v31 = crate::vec3::new(&mut buf)?;
        let v32 = crate::vec3::new(&mut buf)?;
        let v33 = crate::vec3::new(&mut buf)?;
        let v34 = crate::vec3::new(&mut buf)?;
        let v41 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec3::new(&mut buf)?); } _e0 };
        let v42 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec3::new(&mut buf)?); } _e0 };
        let v43 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec3::new(&mut buf)?); } _e0 };
        let v44 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::vec3::new(&mut buf)?); } _e0 };
        
        Ok(TestFormat { id, a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, m1, m2, m3, m4, v31, v32, v33, v34, v41, v42, v43, v44, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -38307291;
}

#[derive(Debug)]
pub struct TestGlobal {
    pub unlock_equip: i32,
    pub unlock_hero: i32,
}

impl TestGlobal{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestGlobal, LubanError> {
        let unlock_equip = buf.read_int();
        let unlock_hero = buf.read_int();
        
        Ok(TestGlobal { unlock_equip, unlock_hero, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -12548655;
}

#[derive(Debug)]
pub struct TestIndex {
    pub id: i32,
    pub eles: Vec<crate::test::DemoType1>,
}

impl TestIndex{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestIndex, LubanError> {
        let id = buf.read_int();
        let eles = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoType1::new(&mut buf)?); } _e0 };
        
        Ok(TestIndex { id, eles, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.eles.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }

    pub const __ID__: i32 = 1941154020;
}

#[derive(Debug)]
pub struct TestMap {
    pub id: i32,
    pub id_ref: Option<std::sync::Arc<crate::test::TestIndex>>,
    pub x1: std::collections::HashMap<i32, i32>,
    pub x2: std::collections::HashMap<i64, i32>,
    pub x3: std::collections::HashMap<String, i32>,
    pub x4: std::collections::HashMap<crate::test::DemoEnum, i32>,
}

impl TestMap{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestMap, LubanError> {
        let id = buf.read_int();
        let id_ref = None;
        let x1 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_long(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_string(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int().into(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        
        Ok(TestMap { id, id_ref, x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.id_ref = tables.TbTestIndex.get(&self.id);
    }

    pub const __ID__: i32 = -543227410;
}

#[derive(Debug)]
pub struct TestMapper {
    pub id: i32,
    pub audio_type: crate::AudioType,
    pub v2: crate::vec2,
}

impl TestMapper{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestMapper, LubanError> {
        let id = buf.read_int();
        let audio_type = buf.read_int().into();
        let v2 = crate::vec2::new(&mut buf)?;
        
        Ok(TestMapper { id, audio_type, v2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 149110895;
}

#[derive(Debug)]
pub struct TestMultiColumn {
    pub id: i32,
    pub a: crate::test::Foo,
    pub b: crate::test::Foo,
    pub c: crate::test::Foo,
}

impl TestMultiColumn{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestMultiColumn, LubanError> {
        let id = buf.read_int();
        let a = crate::test::Foo::new(&mut buf)?;
        let b = crate::test::Foo::new(&mut buf)?;
        let c = crate::test::Foo::new(&mut buf)?;
        
        Ok(TestMultiColumn { id, a, b, c, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.a.resolve_ref(tables);
        self.b.resolve_ref(tables);
        self.c.resolve_ref(tables);
    }

    pub const __ID__: i32 = -294473599;
}

#[derive(Debug)]
pub struct TestNull {
    pub id: i32,
    pub x1: Option<i32>,
    pub x2: Option<crate::test::DemoEnum>,
    pub x3: Option<crate::test::DemoType1>,
    pub x4: Option<crate::test::DemoDynamic>,
    pub s1: Option<String>,
    pub s2: Option<String>,
}

impl TestNull{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestNull, LubanError> {
        let id = buf.read_int();
        let mut x1 = if buf.read_bool() { Some(buf.read_int()) } else { None };
        let mut x2 = if buf.read_bool() { Some(buf.read_int().into()) } else { None };
        let mut x3 = if buf.read_bool() { Some(crate::test::DemoType1::new(&mut buf)?) } else { None };
        let mut x4 = if buf.read_bool() { Some(crate::test::DemoDynamic::new(&mut buf)?) } else { None };
        let mut s1 = if buf.read_bool() { Some(buf.read_string()) } else { None };
        let mut s2 = if buf.read_bool() { Some(buf.read_string()) } else { None };
        
        Ok(TestNull { id, x1, x2, x3, x4, s1, s2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        if let Some(x) = &mut self.x3 { x.resolve_ref(tables); }
        if let Some(x) = &mut self.x4 { x.resolve_ref(tables); }
    }

    pub const __ID__: i32 = 339868469;
}

#[derive(Debug)]
pub struct TestRange {
    pub id: i32,
    pub f1: f32,
    pub f2: f32,
    pub d1: f64,
    pub d2: f64,
    pub i1: i32,
    pub i2: i32,
    pub i3: i32,
    pub i4: i32,
    pub l1: i64,
    pub l2: i64,
    pub l3: i64,
    pub l4: i64,
}

impl TestRange{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestRange, LubanError> {
        let id = buf.read_int();
        let f1 = buf.read_float();
        let f2 = buf.read_float();
        let d1 = buf.read_double();
        let d2 = buf.read_double();
        let i1 = buf.read_int();
        let i2 = buf.read_int();
        let i3 = buf.read_int();
        let i4 = buf.read_int();
        let l1 = buf.read_long();
        let l2 = buf.read_long();
        let l3 = buf.read_long();
        let l4 = buf.read_long();
        
        Ok(TestRange { id, f1, f2, d1, d2, i1, i2, i3, i4, l1, l2, l3, l4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 1949088079;
}

#[derive(Debug)]
pub struct TestRef {
    pub id: i32,
    pub x1: i32,
    pub x1_ref: Option<std::sync::Arc<crate::test::TestBeRef>>,
    pub x1_2: i32,
    pub x1_2_ref: Option<std::sync::Arc<crate::test::TestBeRef>>,
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub x4_ref: Option<std::sync::Arc<crate::tag::TestTag>>,
    pub a1: Vec<i32>,
    pub a1_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub a2: Vec<i32>,
    pub a2_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub b1: Vec<i32>,
    pub b1_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub b2: Vec<i32>,
    pub b2_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub c1: std::collections::HashSet<i32>,
    pub c1_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub c2: std::collections::HashSet<i32>,
    pub c2_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub d1: std::collections::HashMap<i32, i32>,
    pub d1_ref: Option<std::sync::Arc<std::collections::HashMap<i32, Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub d2: std::collections::HashMap<i32, i32>,
    pub d2_ref: Option<std::sync::Arc<std::collections::HashMap<i32, Option<std::sync::Arc<crate::test::TestBeRef>>>>>,
    pub e1: i32,
    pub e2: i64,
    pub e3: String,
    pub f1: i32,
    pub f2: i64,
    pub f3: String,
    pub s1: crate::test::RefDynamicBase,
}

impl TestRef{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestRef, LubanError> {
        let id = buf.read_int();
        let x1 = buf.read_int();
        let x1_ref = None;
        let x1_2 = buf.read_int();
        let x1_2_ref = None;
        let x2 = buf.read_int();
        let x3 = buf.read_int();
        let x4 = buf.read_int();
        let x4_ref = None;
        let a1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let a1_ref = None;
        let a2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let a2_ref = None;
        let b1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b1_ref = None;
        let b2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let b2_ref = None;
        let c1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let c1_ref = None;
        let c2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let c2_ref = None;
        let d1 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let d1_ref = None;
        let d2 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let d2_ref = None;
        let e1 = buf.read_int();
        let e2 = buf.read_long();
        let e3 = buf.read_string();
        let f1 = buf.read_int();
        let f2 = buf.read_long();
        let f3 = buf.read_string();
        let s1 = crate::test::RefDynamicBase::new(&mut buf)?;
        
        Ok(TestRef { id, x1, x1_ref, x1_2, x1_2_ref, x2, x3, x4, x4_ref, a1, a1_ref, a2, a2_ref, b1, b1_ref, b2, b2_ref, c1, c1_ref, c2, c2_ref, d1, d1_ref, d2, d2_ref, e1, e2, e3, f1, f2, f3, s1, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x1_ref = tables.TbTestBeRef.get(&self.x1);
        self.x1_2_ref = tables.TbTestBeRef.get(&self.x1_2);
        self.x4_ref = tables.TbTestTag.get(&self.x4);
        self.a1_ref = Some(std::sync::Arc::new(self.a1.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.a2_ref = Some(std::sync::Arc::new(self.a2.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.b1_ref = Some(std::sync::Arc::new(self.b1.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.b2_ref = Some(std::sync::Arc::new(self.b2.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        //HashSet does not support yet, not every type implement [Eq] and [Hash],use list instead.
        self.c1_ref = Some(std::sync::Arc::new(self.c1.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        //HashSet does not support yet, not every type implement [Eq] and [Hash],use list instead.
        self.c2_ref = Some(std::sync::Arc::new(self.c2.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.d1_ref = Some(std::sync::Arc::new(self.d1.iter().map(|x| (x.0.clone(), tables.TbTestBeRef.get(x.1))).collect()));
        self.d2_ref = Some(std::sync::Arc::new(self.d2.iter().map(|x| (x.0.clone(), tables.TbTestBeRef.get(x.1))).collect()));
        self.s1.resolve_ref(tables);
    }

    pub const __ID__: i32 = -543222491;
}

#[derive(Debug)]
pub struct TestRow {
    pub x: i32,
    pub y: bool,
    pub z: String,
    pub a: crate::test::Test3,
    pub b: Vec<i32>,
}

impl TestRow{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestRow, LubanError> {
        let x = buf.read_int();
        let y = buf.read_bool();
        let z = buf.read_string();
        let a = crate::test::Test3::new(&mut buf)?;
        let b = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        
        Ok(TestRow { x, y, z, a, b, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.a.resolve_ref(tables);
    }

    pub const __ID__: i32 = -543222164;
}

#[derive(Debug)]
pub struct TestScriptableObject {
    pub id: i32,
    pub desc: String,
    pub rate: f32,
    pub num: i32,
    pub v2: crate::vec2,
    pub v3: crate::vec3,
    pub v4: crate::vec4,
}

impl TestScriptableObject{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestScriptableObject, LubanError> {
        let id = buf.read_int();
        let desc = buf.read_string();
        let rate = buf.read_float();
        let num = buf.read_int();
        let v2 = crate::vec2::new(&mut buf)?;
        let v3 = crate::vec3::new(&mut buf)?;
        let v4 = crate::vec4::new(&mut buf)?;
        
        Ok(TestScriptableObject { id, desc, rate, num, v2, v3, v4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -1896814350;
}

#[derive(Debug)]
pub struct TestSet {
    pub id: i32,
    pub x0: String,
    pub x1: Vec<i32>,
    pub x2: Vec<i64>,
    pub x3: Vec<String>,
    pub x4: Vec<crate::test::DemoEnum>,
}

impl TestSet{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestSet, LubanError> {
        let id = buf.read_int();
        let x0 = buf.read_string();
        let x1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_long()); } _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_string()); } _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int().into()); } _e0 };
        
        Ok(TestSet { id, x0, x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = -543221516;
}

#[derive(Debug)]
pub struct TestSize {
    pub id: i32,
    pub x1: Vec<i32>,
    pub x2: Vec<i32>,
    pub x3: std::collections::HashSet<i32>,
    pub x4: std::collections::HashMap<i32, i32>,
}

impl TestSize{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestSize, LubanError> {
        let id = buf.read_int();
        let x1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let x2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let x3 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let x4 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        
        Ok(TestSize { id, x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }

    pub const __ID__: i32 = 340006319;
}

#[derive(Debug)]
pub struct TestString {
    pub id: String,
    pub s1: String,
    pub s2: String,
    pub cs1: crate::test::CompactString,
    pub cs2: crate::test::CompactString,
    pub css: Vec<String>,
    pub css2: Vec<String>,
}

impl TestString{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestString, LubanError> {
        let id = buf.read_string();
        let s1 = buf.read_string();
        let s2 = buf.read_string();
        let cs1 = crate::test::CompactString::new(&mut buf)?;
        let cs2 = crate::test::CompactString::new(&mut buf)?;
        let css = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_string()); } _e0 };
        let css2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_string()); } _e0 };
        
        Ok(TestString { id, s1, s2, cs1, cs2, css, css2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.cs1.resolve_ref(tables);
        self.cs2.resolve_ref(tables);
    }

    pub const __ID__: i32 = 338485823;
}

#[derive(Debug)]
pub struct TestUeType {
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x4: i32,
    pub x5: i64,
    pub x6: f32,
    pub x10: String,
    pub x12: crate::test::DemoType1,
    pub x13: crate::test::ETestUeType,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k5: std::collections::HashSet<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<crate::test::DemoE2>,
}

impl TestUeType{
    pub(crate) fn new(mut buf: &mut ByteBuf) -> Result<TestUeType, LubanError> {
        let x1 = buf.read_bool();
        let x2 = buf.read_byte();
        let x3 = buf.read_short();
        let x4 = buf.read_int();
        let x5 = buf.read_long();
        let x6 = buf.read_float();
        let x10 = buf.read_string();
        let x12 = crate::test::DemoType1::new(&mut buf)?;
        let x13 = buf.read_int().into();
        let t1 = buf.read_ulong();
        let k1 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k2 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(buf.read_int()); } _e0 };
        let k5 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = std::collections::HashSet::default(); for i0 in 0..n0 { _e0.insert(buf.read_int()); } _e0 };
        let k8 = {let n0 = std::cmp::min(buf.read_size(), buf.size()); let mut _e0 = std::collections::HashMap::with_capacity(n0 * 3 / 2);for i0 in 0..n0 { let _k0 = buf.read_int(); let _v0 = buf.read_int(); _e0.insert(_k0, _v0);} _e0 };
        let k9 = {let n0 = std::cmp::min(buf.read_size(), buf.size());let mut _e0 = vec![]; for i0 in 0..n0 { _e0.push(crate::test::DemoE2::new(&mut buf)?); } _e0 };
        
        Ok(TestUeType { x1, x2, x3, x4, x5, x6, x10, x12, x13, t1, k1, k2, k5, k8, k9, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x12.resolve_ref(tables);
    }

    pub const __ID__: i32 = 381013016;
}


#[derive(Debug)]
pub struct TbFullTypes {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>>,
}

impl TbFullTypes {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbFullTypes>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoType2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoType2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbFullTypes { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoType2 as *mut crate::test::DemoType2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbFullTypes {
    type Output = std::sync::Arc<crate::test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbSingleton {
    pub data: crate::test::DemoSingletonType,
}

impl TbSingleton {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbSingleton>, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::DemoSingletonType::new(&mut buf)?;
        Ok(std::sync::Arc::new(TbSingleton { data }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }
}


#[derive(Debug)]
pub struct TbNotIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::NotIndexList>>,
}

impl TbNotIndexList {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbNotIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::NotIndexList>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::NotIndexList::new(&mut buf)?);
            data_list.push(row.clone());
        }

    Ok(std::sync::Arc::new(TbNotIndexList { 
            data_list,
        }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::NotIndexList as *mut crate::test::NotIndexList); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}


#[derive(Debug)]
pub struct TbMultiUnionIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>>,
    pub data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<crate::test::MultiUnionIndexList>>,
}

impl TbMultiUnionIndexList {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiUnionIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiUnionIndexList>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiUnionIndexList::new(&mut buf)?);
            data_list.push(row.clone());
        }
        let mut data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<crate::test::MultiUnionIndexList>> = Default::default();
        for x in &data_list {
            data_map_union.insert((x.id1, x.id2, x.id3.clone()), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiUnionIndexList { 
            data_list,
            data_map_union,
        }))
    }
    
    pub fn get(&self, key: &(i32, i64, String)) -> Option<std::sync::Arc<crate::test::MultiUnionIndexList>> {
        self.data_map_union.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::MultiUnionIndexList as *mut crate::test::MultiUnionIndexList); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}


#[derive(Debug)]
pub struct TbMultiIndexList {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id1: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id2: std::collections::HashMap<i64, std::sync::Arc<crate::test::MultiIndexList>>,
    pub data_map_id3: std::collections::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>>,
}

impl TbMultiIndexList {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiIndexList>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiIndexList::new(&mut buf)?);
            data_list.push(row.clone());
        }
        let mut data_map_id1: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id2: std::collections::HashMap<i64, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        let mut data_map_id3: std::collections::HashMap<String, std::sync::Arc<crate::test::MultiIndexList>> = Default::default();
        for x in &data_list {
            data_map_id1.insert(x.id1.clone(), x.clone());
            data_map_id2.insert(x.id2.clone(), x.clone());
            data_map_id3.insert(x.id3.clone(), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiIndexList { 
            data_list,
            data_map_id1,
            data_map_id2,
            data_map_id3,
        }))
    }
    pub fn get_by_id1(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id1.get(key).map(|x| x.clone())
    }
    pub fn get_by_id2(&self, key: &i64) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id2.get(key).map(|x| x.clone())
    }
    pub fn get_by_id3(&self, key: &String) -> Option<std::sync::Arc<crate::test::MultiIndexList>> {
        self.data_map_id3.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::MultiIndexList as *mut crate::test::MultiIndexList); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}


#[derive(Debug)]
pub struct TbDataFromMisc {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>>,
}

impl TbDataFromMisc {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDataFromMisc>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoType2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoType2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDataFromMisc { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoType2 as *mut crate::test::DemoType2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDataFromMisc {
    type Output = std::sync::Arc<crate::test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowRecord {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiRowRecord>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowRecord>>,
}

impl TbMultiRowRecord {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiRowRecord>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowRecord>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiRowRecord>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiRowRecord::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowRecord { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiRowRecord>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::MultiRowRecord as *mut crate::test::MultiRowRecord); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbMultiRowRecord {
    type Output = std::sync::Arc<crate::test::MultiRowRecord>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMultiColumn {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMultiColumn>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMultiColumn>>,
}

impl TbTestMultiColumn {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestMultiColumn>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMultiColumn>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMultiColumn>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestMultiColumn::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMultiColumn { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMultiColumn>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestMultiColumn as *mut crate::test::TestMultiColumn); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestMultiColumn {
    type Output = std::sync::Arc<crate::test::TestMultiColumn>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowTitle {
    pub data_list: Vec<std::sync::Arc<crate::test::MultiRowTitle>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowTitle>>,
}

impl TbMultiRowTitle {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbMultiRowTitle>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::MultiRowTitle>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::MultiRowTitle>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::MultiRowTitle::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowTitle { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::MultiRowTitle>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::MultiRowTitle as *mut crate::test::MultiRowTitle); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbMultiRowTitle {
    type Output = std::sync::Arc<crate::test::MultiRowTitle>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestNull {
    pub data_list: Vec<std::sync::Arc<crate::test::TestNull>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestNull>>,
}

impl TbTestNull {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestNull>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestNull>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestNull>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestNull::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestNull { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestNull>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestNull as *mut crate::test::TestNull); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestNull {
    type Output = std::sync::Arc<crate::test::TestNull>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoPrimitive {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoPrimitiveTypesTable>>,
}

impl TbDemoPrimitive {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoPrimitive>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoPrimitiveTypesTable::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoPrimitive { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoPrimitiveTypesTable>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoPrimitiveTypesTable as *mut crate::test::DemoPrimitiveTypesTable); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoPrimitive {
    type Output = std::sync::Arc<crate::test::DemoPrimitiveTypesTable>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestString {
    pub data_list: Vec<std::sync::Arc<crate::test::TestString>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::test::TestString>>,
}

impl TbTestString {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestString>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<crate::test::TestString>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestString>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestString::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestString { data_map, data_list }))
    }

    pub fn get(&self, key: &String) -> Option<std::sync::Arc<crate::test::TestString>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestString as *mut crate::test::TestString); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<String> for TbTestString {
    type Output = std::sync::Arc<crate::test::TestString>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoGroup as *mut crate::test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_C {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_C {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup_C>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_C { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoGroup as *mut crate::test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup_C {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_S {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_S {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup_S>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_S { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoGroup as *mut crate::test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup_S {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_E {
    pub data_list: Vec<std::sync::Arc<crate::test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>>,
}

impl TbDemoGroup_E {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDemoGroup_E>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DemoGroup>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DemoGroup::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_E { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DemoGroup as *mut crate::test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup_E {
    type Output = std::sync::Arc<crate::test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestGlobal {
    pub data: crate::test::TestGlobal,
}

impl TbTestGlobal {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestGlobal>, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::TestGlobal::new(&mut buf)?;
        Ok(std::sync::Arc::new(TbTestGlobal { data }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }
}


#[derive(Debug)]
pub struct TbTestBeRef {
    pub data_list: Vec<std::sync::Arc<crate::test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>>,
}

impl TbTestBeRef {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestBeRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestBeRef>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestBeRef::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestBeRef as *mut crate::test::TestBeRef); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestBeRef {
    type Output = std::sync::Arc<crate::test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestBeRef2 {
    pub data_list: Vec<std::sync::Arc<crate::test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>>,
}

impl TbTestBeRef2 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestBeRef2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestBeRef>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestBeRef::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestBeRef as *mut crate::test::TestBeRef); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestBeRef2 {
    type Output = std::sync::Arc<crate::test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestRef {
    pub data_list: Vec<std::sync::Arc<crate::test::TestRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRef>>,
}

impl TbTestRef {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestRef>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestRef::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestRef as *mut crate::test::TestRef); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestRef {
    type Output = std::sync::Arc<crate::test::TestRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSize {
    pub data_list: Vec<std::sync::Arc<crate::test::TestSize>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSize>>,
}

impl TbTestSize {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestSize>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSize>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestSize>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestSize::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSize { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestSize>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestSize as *mut crate::test::TestSize); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestSize {
    type Output = std::sync::Arc<crate::test::TestSize>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSet {
    pub data_list: Vec<std::sync::Arc<crate::test::TestSet>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSet>>,
}

impl TbTestSet {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestSet>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestSet>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestSet>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestSet::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSet { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestSet>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestSet as *mut crate::test::TestSet); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestSet {
    type Output = std::sync::Arc<crate::test::TestSet>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestRange {
    pub data_list: Vec<std::sync::Arc<crate::test::TestRange>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRange>>,
}

impl TbTestRange {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestRange>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestRange>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestRange>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestRange::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestRange { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestRange>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestRange as *mut crate::test::TestRange); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestRange {
    type Output = std::sync::Arc<crate::test::TestRange>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDetectCsvEncoding {
    pub data_list: Vec<std::sync::Arc<crate::test::DetectEncoding>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DetectEncoding>>,
}

impl TbDetectCsvEncoding {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDetectCsvEncoding>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DetectEncoding>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DetectEncoding>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DetectEncoding::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDetectCsvEncoding { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DetectEncoding>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DetectEncoding as *mut crate::test::DetectEncoding); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDetectCsvEncoding {
    type Output = std::sync::Arc<crate::test::DetectEncoding>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbItem2 {
    pub data_list: Vec<std::sync::Arc<crate::test::ItemBase>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ItemBase>>,
}

impl TbItem2 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbItem2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ItemBase>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::ItemBase>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::ItemBase::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.get_id().clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbItem2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::ItemBase>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::ItemBase as *mut crate::test::ItemBase); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbItem2 {
    type Output = std::sync::Arc<crate::test::ItemBase>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestIndex {
    pub data_list: Vec<std::sync::Arc<crate::test::TestIndex>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestIndex>>,
}

impl TbTestIndex {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestIndex>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestIndex>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestIndex>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestIndex::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestIndex { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestIndex>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestIndex as *mut crate::test::TestIndex); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestIndex {
    type Output = std::sync::Arc<crate::test::TestIndex>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMap {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMap>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMap>>,
}

impl TbTestMap {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestMap>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMap>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMap>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestMap::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMap { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMap>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestMap as *mut crate::test::TestMap); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestMap {
    type Output = std::sync::Arc<crate::test::TestMap>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbExcelFromJson {
    pub data_list: Vec<std::sync::Arc<crate::test::ExcelFromJson>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJson>>,
}

impl TbExcelFromJson {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbExcelFromJson>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJson>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::ExcelFromJson>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::ExcelFromJson::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJson { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::ExcelFromJson>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::ExcelFromJson as *mut crate::test::ExcelFromJson); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbExcelFromJson {
    type Output = std::sync::Arc<crate::test::ExcelFromJson>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable1 {
    pub data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable1>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable1>>,
}

impl TbCompositeJsonTable1 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbCompositeJsonTable1>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable1>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable1>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::CompositeJsonTable1::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable1 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::CompositeJsonTable1>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::CompositeJsonTable1 as *mut crate::test::CompositeJsonTable1); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable1 {
    type Output = std::sync::Arc<crate::test::CompositeJsonTable1>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable2 {
    pub data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable2>>,
}

impl TbCompositeJsonTable2 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbCompositeJsonTable2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::CompositeJsonTable2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::CompositeJsonTable2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::CompositeJsonTable2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::CompositeJsonTable2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::CompositeJsonTable2 as *mut crate::test::CompositeJsonTable2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable2 {
    type Output = std::sync::Arc<crate::test::CompositeJsonTable2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable3 {
    pub data: crate::test::CompositeJsonTable3,
}

impl TbCompositeJsonTable3 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbCompositeJsonTable3>, LubanError> {
        let n = buf.read_size();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = crate::test::CompositeJsonTable3::new(&mut buf)?;
        Ok(std::sync::Arc::new(TbCompositeJsonTable3 { data }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }
}


#[derive(Debug)]
pub struct TbExcelFromJsonMultiRow {
    pub data_list: Vec<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJsonMultiRow>>,
}

impl TbExcelFromJsonMultiRow {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbExcelFromJsonMultiRow>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::ExcelFromJsonMultiRow::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJsonMultiRow { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::ExcelFromJsonMultiRow>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::ExcelFromJsonMultiRow as *mut crate::test::ExcelFromJsonMultiRow); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbExcelFromJsonMultiRow {
    type Output = std::sync::Arc<crate::test::ExcelFromJsonMultiRow>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestScriptableObject {
    pub data_list: Vec<std::sync::Arc<crate::test::TestScriptableObject>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestScriptableObject>>,
}

impl TbTestScriptableObject {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestScriptableObject>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestScriptableObject>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestScriptableObject>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestScriptableObject::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestScriptableObject { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestScriptableObject>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestScriptableObject as *mut crate::test::TestScriptableObject); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestScriptableObject {
    type Output = std::sync::Arc<crate::test::TestScriptableObject>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbPath {
    pub data_list: Vec<std::sync::Arc<crate::test::Path>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::Path>>,
}

impl TbPath {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbPath>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::Path>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::Path>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::Path::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbPath { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::Path>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::Path as *mut crate::test::Path); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbPath {
    type Output = std::sync::Arc<crate::test::Path>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFieldAlias {
    pub data_list: Vec<std::sync::Arc<crate::test::TestFieldAlias>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFieldAlias>>,
}

impl TbTestFieldAlias {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestFieldAlias>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFieldAlias>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestFieldAlias>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestFieldAlias::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFieldAlias { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestFieldAlias>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestFieldAlias as *mut crate::test::TestFieldAlias); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFieldAlias {
    type Output = std::sync::Arc<crate::test::TestFieldAlias>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFieldVariant {
    pub data_list: Vec<std::sync::Arc<crate::test::TestFieldVariant>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFieldVariant>>,
}

impl TbTestFieldVariant {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestFieldVariant>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFieldVariant>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestFieldVariant>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestFieldVariant::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFieldVariant { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestFieldVariant>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestFieldVariant as *mut crate::test::TestFieldVariant); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFieldVariant {
    type Output = std::sync::Arc<crate::test::TestFieldVariant>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFieldVariant2 {
    pub data_list: Vec<std::sync::Arc<crate::test::TestFieldVariant2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFieldVariant2>>,
}

impl TbTestFieldVariant2 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestFieldVariant2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFieldVariant2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestFieldVariant2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestFieldVariant2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFieldVariant2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestFieldVariant2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestFieldVariant2 as *mut crate::test::TestFieldVariant2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFieldVariant2 {
    type Output = std::sync::Arc<crate::test::TestFieldVariant2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMapper {
    pub data_list: Vec<std::sync::Arc<crate::test::TestMapper>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMapper>>,
}

impl TbTestMapper {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestMapper>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestMapper>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestMapper>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestMapper::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMapper { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestMapper>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestMapper as *mut crate::test::TestMapper); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestMapper {
    type Output = std::sync::Arc<crate::test::TestMapper>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDefineFromExcel2 {
    pub data_list: Vec<std::sync::Arc<crate::test::DefineFromExcel2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DefineFromExcel2>>,
}

impl TbDefineFromExcel2 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbDefineFromExcel2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::DefineFromExcel2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::DefineFromExcel2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::DefineFromExcel2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDefineFromExcel2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::DefineFromExcel2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::DefineFromExcel2 as *mut crate::test::DefineFromExcel2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDefineFromExcel2 {
    type Output = std::sync::Arc<crate::test::DefineFromExcel2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbAutoImport2 {
    pub data_list: Vec<std::sync::Arc<crate::test::AutoImport2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::AutoImport2>>,
}

impl TbAutoImport2 {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbAutoImport2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::AutoImport2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::AutoImport2>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::AutoImport2::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbAutoImport2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::AutoImport2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::AutoImport2 as *mut crate::test::AutoImport2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbAutoImport2 {
    type Output = std::sync::Arc<crate::test::AutoImport2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFormat {
    pub data_list: Vec<std::sync::Arc<crate::test::TestFormat>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFormat>>,
}

impl TbTestFormat {
    pub(crate) fn new(mut buf: ByteBuf) -> Result<std::sync::Arc<TbTestFormat>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::test::TestFormat>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::test::TestFormat>> = vec![];

        for x in (0..buf.read_size()).rev() {
            let row = std::sync::Arc::new(crate::test::TestFormat::new(&mut buf)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFormat { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::test::TestFormat>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::test::TestFormat as *mut crate::test::TestFormat); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFormat {
    type Output = std::sync::Arc<crate::test::TestFormat>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


