
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/


use super::*;
use serde::Deserialize;

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EExecutor {
    CLIENT = 0,
    SERVER = 1,
}

impl From<i32> for EExecutor {
    fn from(value: i32) -> Self {
        match value {
            0 => EExecutor::CLIENT,
            1 => EExecutor::SERVER,
            _ => panic!("Invalid value for EExecutor:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EFinishMode {
    IMMEDIATE = 0,
    DELAYED = 1,
}

impl From<i32> for EFinishMode {
    fn from(value: i32) -> Self {
        match value {
            0 => EFinishMode::IMMEDIATE,
            1 => EFinishMode::DELAYED,
            _ => panic!("Invalid value for EFinishMode:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EFlowAbortMode {
    NONE = 0,
    LOWER_PRIORITY = 1,
    SELF = 2,
    BOTH = 3,
}

impl From<i32> for EFlowAbortMode {
    fn from(value: i32) -> Self {
        match value {
            0 => EFlowAbortMode::NONE,
            1 => EFlowAbortMode::LOWER_PRIORITY,
            2 => EFlowAbortMode::SELF,
            3 => EFlowAbortMode::BOTH,
            _ => panic!("Invalid value for EFlowAbortMode:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EKeyType {
    BOOL = 1,
    INT = 2,
    FLOAT = 3,
    STRING = 4,
    VECTOR = 5,
    ROTATOR = 6,
    NAME = 7,
    CLASS1 = 8,
    ENUM1 = 9,
    OBJECT = 10,
}

impl From<i32> for EKeyType {
    fn from(value: i32) -> Self {
        match value {
            1 => EKeyType::BOOL,
            2 => EKeyType::INT,
            3 => EKeyType::FLOAT,
            4 => EKeyType::STRING,
            5 => EKeyType::VECTOR,
            6 => EKeyType::ROTATOR,
            7 => EKeyType::NAME,
            8 => EKeyType::CLASS1,
            9 => EKeyType::ENUM1,
            10 => EKeyType::OBJECT,
            _ => panic!("Invalid value for EKeyType:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum ENotifyObserverMode {
    ON_VALUE_CHANGE = 0,
    ON_RESULT_CHANGE = 1,
}

impl From<i32> for ENotifyObserverMode {
    fn from(value: i32) -> Self {
        match value {
            0 => ENotifyObserverMode::ON_VALUE_CHANGE,
            1 => ENotifyObserverMode::ON_RESULT_CHANGE,
            _ => panic!("Invalid value for ENotifyObserverMode:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, macros::EnumFromNum)]
pub enum EOperator {
    IS_EQUAL_TO = 0,
    IS_NOT_EQUAL_TO = 1,
    IS_LESS_THAN = 2,
    IS_LESS_THAN_OR_EQUAL_TO = 3,
    IS_GREAT_THAN = 4,
    IS_GREAT_THAN_OR_EQUAL_TO = 5,
    CONTAINS = 6,
    NOT_CONTAINS = 7,
}

impl From<i32> for EOperator {
    fn from(value: i32) -> Self {
        match value {
            0 => EOperator::IS_EQUAL_TO,
            1 => EOperator::IS_NOT_EQUAL_TO,
            2 => EOperator::IS_LESS_THAN,
            3 => EOperator::IS_LESS_THAN_OR_EQUAL_TO,
            4 => EOperator::IS_GREAT_THAN,
            5 => EOperator::IS_GREAT_THAN_OR_EQUAL_TO,
            6 => EOperator::CONTAINS,
            7 => EOperator::NOT_CONTAINS,
            _ => panic!("Invalid value for EOperator:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct BehaviorTree {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub blackboard_id: String,
    pub blackboard_id_ref: Option<std::sync::Arc<crate::ai::Blackboard>>,
    pub root: crate::ai::ComposeNode,
}

impl BehaviorTree{
    pub(crate) fn new(json: &serde_json::Value) -> Result<BehaviorTree, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let blackboard_id = json["blackboard_id"].as_str().unwrap().to_string();
        let blackboard_id_ref = None;
        let root = crate::ai::ComposeNode::new(&json["root"])?;
        
        Ok(BehaviorTree { id, name, desc, blackboard_id, blackboard_id_ref, root, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.blackboard_id_ref = tables.TbBlackboard.get(&self.blackboard_id);
        self.root.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct Blackboard {
    pub name: String,
    pub desc: String,
    pub parent_name: String,
    pub parent_name_ref: Option<std::sync::Arc<crate::ai::Blackboard>>,
    pub keys: Vec<crate::ai::BlackboardKey>,
}

impl Blackboard{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Blackboard, LubanError> {
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let parent_name = json["parent_name"].as_str().unwrap().to_string();
        let parent_name_ref = None;
        let keys = json["keys"].as_array().unwrap().iter().map(|field| crate::ai::BlackboardKey::new(&field).unwrap()).collect();
        
        Ok(Blackboard { name, desc, parent_name, parent_name_ref, keys, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.parent_name_ref = tables.TbBlackboard.get(&self.parent_name);
        self.keys.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct BlackboardKey {
    pub name: String,
    pub desc: String,
    pub is_static: bool,
    pub key_type: crate::ai::EKeyType,
    pub type_class_name: String,
}

impl BlackboardKey{
    pub(crate) fn new(json: &serde_json::Value) -> Result<BlackboardKey, LubanError> {
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let is_static = json["is_static"].as_bool().unwrap();
        let key_type = json["key_type"].as_i64().unwrap().into();
        let type_class_name = json["type_class_name"].as_str().unwrap().to_string();
        
        Ok(BlackboardKey { name, desc, is_static, key_type, type_class_name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum KeyData {
    FloatKeyData(std::sync::Arc<crate::ai::FloatKeyData>),
    IntKeyData(std::sync::Arc<crate::ai::IntKeyData>),
    StringKeyData(std::sync::Arc<crate::ai::StringKeyData>),
    BlackboardKeyData(std::sync::Arc<crate::ai::BlackboardKeyData>),
}

impl KeyData {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "FloatKeyData" => Ok(Self::FloatKeyData(std::sync::Arc::new(crate::ai::FloatKeyData::new(json)?))),
            "IntKeyData" => Ok(Self::IntKeyData(std::sync::Arc::new(crate::ai::IntKeyData::new(json)?))),
            "StringKeyData" => Ok(Self::StringKeyData(std::sync::Arc::new(crate::ai::StringKeyData::new(json)?))),
            "BlackboardKeyData" => Ok(Self::BlackboardKeyData(std::sync::Arc::new(crate::ai::BlackboardKeyData::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyData:{}", type_id)))
        }
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::FloatKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::FloatKeyData as *mut crate::ai::FloatKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IntKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::IntKeyData as *mut crate::ai::IntKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::StringKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::StringKeyData as *mut crate::ai::StringKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::BlackboardKeyData(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::BlackboardKeyData as *mut crate::ai::BlackboardKeyData); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct BlackboardKeyData {
    pub value: String,
}

impl BlackboardKeyData{
    pub(crate) fn new(json: &serde_json::Value) -> Result<BlackboardKeyData, LubanError> {
        let value = json["value"].as_str().unwrap().to_string();
        
        Ok(BlackboardKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct FloatKeyData {
    pub value: f32,
}

impl FloatKeyData{
    pub(crate) fn new(json: &serde_json::Value) -> Result<FloatKeyData, LubanError> {
        let value = (json["value"].as_f64().unwrap() as f32);
        
        Ok(FloatKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct IntKeyData {
    pub value: i32,
}

impl IntKeyData{
    pub(crate) fn new(json: &serde_json::Value) -> Result<IntKeyData, LubanError> {
        let value = (json["value"].as_i64().unwrap() as i32);
        
        Ok(IntKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct StringKeyData {
    pub value: String,
}

impl StringKeyData{
    pub(crate) fn new(json: &serde_json::Value) -> Result<StringKeyData, LubanError> {
        let value = json["value"].as_str().unwrap().to_string();
        
        Ok(StringKeyData { value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum KeyQueryOperator {
    IsSet2(std::sync::Arc<crate::ai::IsSet2>),
    IsNotSet(std::sync::Arc<crate::ai::IsNotSet>),
    BinaryOperator(std::sync::Arc<crate::ai::BinaryOperator>),
}

impl KeyQueryOperator {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "IsSet2" => Ok(Self::IsSet2(std::sync::Arc::new(crate::ai::IsSet2::new(json)?))),
            "IsNotSet" => Ok(Self::IsNotSet(std::sync::Arc::new(crate::ai::IsNotSet::new(json)?))),
            "BinaryOperator" => Ok(Self::BinaryOperator(std::sync::Arc::new(crate::ai::BinaryOperator::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for KeyQueryOperator:{}", type_id)))
        }
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::IsSet2(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::IsSet2 as *mut crate::ai::IsSet2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IsNotSet(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::IsNotSet as *mut crate::ai::IsNotSet); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::BinaryOperator(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::BinaryOperator as *mut crate::ai::BinaryOperator); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct BinaryOperator {
    pub oper: crate::ai::EOperator,
    pub data: crate::ai::KeyData,
}

impl BinaryOperator{
    pub(crate) fn new(json: &serde_json::Value) -> Result<BinaryOperator, LubanError> {
        let oper = json["oper"].as_i64().unwrap().into();
        let data = crate::ai::KeyData::new(&json["data"])?;
        
        Ok(BinaryOperator { oper, data, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct IsNotSet {
}

impl IsNotSet{
    pub(crate) fn new(json: &serde_json::Value) -> Result<IsNotSet, LubanError> {
        
        Ok(IsNotSet { })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct IsSet2 {
}

impl IsSet2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<IsSet2, LubanError> {
        
        Ok(IsSet2 { })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum Node {
    UeSetDefaultFocus(std::sync::Arc<crate::ai::UeSetDefaultFocus>),
    ExecuteTimeStatistic(std::sync::Arc<crate::ai::ExecuteTimeStatistic>),
    ChooseTarget(std::sync::Arc<crate::ai::ChooseTarget>),
    KeepFaceTarget(std::sync::Arc<crate::ai::KeepFaceTarget>),
    GetOwnerPlayer(std::sync::Arc<crate::ai::GetOwnerPlayer>),
    UpdateDailyBehaviorProps(std::sync::Arc<crate::ai::UpdateDailyBehaviorProps>),
    UeLoop(std::sync::Arc<crate::ai::UeLoop>),
    UeCooldown(std::sync::Arc<crate::ai::UeCooldown>),
    UeTimeLimit(std::sync::Arc<crate::ai::UeTimeLimit>),
    UeBlackboard(std::sync::Arc<crate::ai::UeBlackboard>),
    UeForceSuccess(std::sync::Arc<crate::ai::UeForceSuccess>),
    IsAtLocation(std::sync::Arc<crate::ai::IsAtLocation>),
    DistanceLessThan(std::sync::Arc<crate::ai::DistanceLessThan>),
    Sequence(std::sync::Arc<crate::ai::Sequence>),
    Selector(std::sync::Arc<crate::ai::Selector>),
    SimpleParallel(std::sync::Arc<crate::ai::SimpleParallel>),
    UeWait(std::sync::Arc<crate::ai::UeWait>),
    UeWaitBlackboardTime(std::sync::Arc<crate::ai::UeWaitBlackboardTime>),
    MoveToTarget(std::sync::Arc<crate::ai::MoveToTarget>),
    ChooseSkill(std::sync::Arc<crate::ai::ChooseSkill>),
    MoveToRandomLocation(std::sync::Arc<crate::ai::MoveToRandomLocation>),
    MoveToLocation(std::sync::Arc<crate::ai::MoveToLocation>),
    DebugPrint(std::sync::Arc<crate::ai::DebugPrint>),
}

impl Node {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeSetDefaultFocus" => Ok(Self::UeSetDefaultFocus(std::sync::Arc::new(crate::ai::UeSetDefaultFocus::new(json)?))),
            "ExecuteTimeStatistic" => Ok(Self::ExecuteTimeStatistic(std::sync::Arc::new(crate::ai::ExecuteTimeStatistic::new(json)?))),
            "ChooseTarget" => Ok(Self::ChooseTarget(std::sync::Arc::new(crate::ai::ChooseTarget::new(json)?))),
            "KeepFaceTarget" => Ok(Self::KeepFaceTarget(std::sync::Arc::new(crate::ai::KeepFaceTarget::new(json)?))),
            "GetOwnerPlayer" => Ok(Self::GetOwnerPlayer(std::sync::Arc::new(crate::ai::GetOwnerPlayer::new(json)?))),
            "UpdateDailyBehaviorProps" => Ok(Self::UpdateDailyBehaviorProps(std::sync::Arc::new(crate::ai::UpdateDailyBehaviorProps::new(json)?))),
            "UeLoop" => Ok(Self::UeLoop(std::sync::Arc::new(crate::ai::UeLoop::new(json)?))),
            "UeCooldown" => Ok(Self::UeCooldown(std::sync::Arc::new(crate::ai::UeCooldown::new(json)?))),
            "UeTimeLimit" => Ok(Self::UeTimeLimit(std::sync::Arc::new(crate::ai::UeTimeLimit::new(json)?))),
            "UeBlackboard" => Ok(Self::UeBlackboard(std::sync::Arc::new(crate::ai::UeBlackboard::new(json)?))),
            "UeForceSuccess" => Ok(Self::UeForceSuccess(std::sync::Arc::new(crate::ai::UeForceSuccess::new(json)?))),
            "IsAtLocation" => Ok(Self::IsAtLocation(std::sync::Arc::new(crate::ai::IsAtLocation::new(json)?))),
            "DistanceLessThan" => Ok(Self::DistanceLessThan(std::sync::Arc::new(crate::ai::DistanceLessThan::new(json)?))),
            "Sequence" => Ok(Self::Sequence(std::sync::Arc::new(crate::ai::Sequence::new(json)?))),
            "Selector" => Ok(Self::Selector(std::sync::Arc::new(crate::ai::Selector::new(json)?))),
            "SimpleParallel" => Ok(Self::SimpleParallel(std::sync::Arc::new(crate::ai::SimpleParallel::new(json)?))),
            "UeWait" => Ok(Self::UeWait(std::sync::Arc::new(crate::ai::UeWait::new(json)?))),
            "UeWaitBlackboardTime" => Ok(Self::UeWaitBlackboardTime(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(json)?))),
            "MoveToTarget" => Ok(Self::MoveToTarget(std::sync::Arc::new(crate::ai::MoveToTarget::new(json)?))),
            "ChooseSkill" => Ok(Self::ChooseSkill(std::sync::Arc::new(crate::ai::ChooseSkill::new(json)?))),
            "MoveToRandomLocation" => Ok(Self::MoveToRandomLocation(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(json)?))),
            "MoveToLocation" => Ok(Self::MoveToLocation(std::sync::Arc::new(crate::ai::MoveToLocation::new(json)?))),
            "DebugPrint" => Ok(Self::DebugPrint(std::sync::Arc::new(crate::ai::DebugPrint::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Node:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.id }
            Self::ExecuteTimeStatistic(x) => { &x.id }
            Self::ChooseTarget(x) => { &x.id }
            Self::KeepFaceTarget(x) => { &x.id }
            Self::GetOwnerPlayer(x) => { &x.id }
            Self::UpdateDailyBehaviorProps(x) => { &x.id }
            Self::UeLoop(x) => { &x.id }
            Self::UeCooldown(x) => { &x.id }
            Self::UeTimeLimit(x) => { &x.id }
            Self::UeBlackboard(x) => { &x.id }
            Self::UeForceSuccess(x) => { &x.id }
            Self::IsAtLocation(x) => { &x.id }
            Self::DistanceLessThan(x) => { &x.id }
            Self::Sequence(x) => { &x.id }
            Self::Selector(x) => { &x.id }
            Self::SimpleParallel(x) => { &x.id }
            Self::UeWait(x) => { &x.id }
            Self::UeWaitBlackboardTime(x) => { &x.id }
            Self::MoveToTarget(x) => { &x.id }
            Self::ChooseSkill(x) => { &x.id }
            Self::MoveToRandomLocation(x) => { &x.id }
            Self::MoveToLocation(x) => { &x.id }
            Self::DebugPrint(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.node_name }
            Self::ExecuteTimeStatistic(x) => { &x.node_name }
            Self::ChooseTarget(x) => { &x.node_name }
            Self::KeepFaceTarget(x) => { &x.node_name }
            Self::GetOwnerPlayer(x) => { &x.node_name }
            Self::UpdateDailyBehaviorProps(x) => { &x.node_name }
            Self::UeLoop(x) => { &x.node_name }
            Self::UeCooldown(x) => { &x.node_name }
            Self::UeTimeLimit(x) => { &x.node_name }
            Self::UeBlackboard(x) => { &x.node_name }
            Self::UeForceSuccess(x) => { &x.node_name }
            Self::IsAtLocation(x) => { &x.node_name }
            Self::DistanceLessThan(x) => { &x.node_name }
            Self::Sequence(x) => { &x.node_name }
            Self::Selector(x) => { &x.node_name }
            Self::SimpleParallel(x) => { &x.node_name }
            Self::UeWait(x) => { &x.node_name }
            Self::UeWaitBlackboardTime(x) => { &x.node_name }
            Self::MoveToTarget(x) => { &x.node_name }
            Self::ChooseSkill(x) => { &x.node_name }
            Self::MoveToRandomLocation(x) => { &x.node_name }
            Self::MoveToLocation(x) => { &x.node_name }
            Self::DebugPrint(x) => { &x.node_name }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeSetDefaultFocus(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeSetDefaultFocus as *mut crate::ai::UeSetDefaultFocus); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ExecuteTimeStatistic(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::ExecuteTimeStatistic as *mut crate::ai::ExecuteTimeStatistic); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::ChooseTarget as *mut crate::ai::ChooseTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::KeepFaceTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::KeepFaceTarget as *mut crate::ai::KeepFaceTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::GetOwnerPlayer(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::GetOwnerPlayer as *mut crate::ai::GetOwnerPlayer); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UpdateDailyBehaviorProps(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UpdateDailyBehaviorProps as *mut crate::ai::UpdateDailyBehaviorProps); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeLoop(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeLoop as *mut crate::ai::UeLoop); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeCooldown(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeCooldown as *mut crate::ai::UeCooldown); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeTimeLimit(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeTimeLimit as *mut crate::ai::UeTimeLimit); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeBlackboard(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeBlackboard as *mut crate::ai::UeBlackboard); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeForceSuccess(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeForceSuccess as *mut crate::ai::UeForceSuccess); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IsAtLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::IsAtLocation as *mut crate::ai::IsAtLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DistanceLessThan(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::DistanceLessThan as *mut crate::ai::DistanceLessThan); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Sequence(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::Sequence as *mut crate::ai::Sequence); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Selector(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::Selector as *mut crate::ai::Selector); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::SimpleParallel(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::SimpleParallel as *mut crate::ai::SimpleParallel); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWait(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeWait as *mut crate::ai::UeWait); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWaitBlackboardTime(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeWaitBlackboardTime as *mut crate::ai::UeWaitBlackboardTime); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToTarget as *mut crate::ai::MoveToTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseSkill(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::ChooseSkill as *mut crate::ai::ChooseSkill); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToRandomLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToRandomLocation as *mut crate::ai::MoveToRandomLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToLocation as *mut crate::ai::MoveToLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DebugPrint(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::DebugPrint as *mut crate::ai::DebugPrint); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub enum Decorator {
    UeLoop(std::sync::Arc<crate::ai::UeLoop>),
    UeCooldown(std::sync::Arc<crate::ai::UeCooldown>),
    UeTimeLimit(std::sync::Arc<crate::ai::UeTimeLimit>),
    UeBlackboard(std::sync::Arc<crate::ai::UeBlackboard>),
    UeForceSuccess(std::sync::Arc<crate::ai::UeForceSuccess>),
    IsAtLocation(std::sync::Arc<crate::ai::IsAtLocation>),
    DistanceLessThan(std::sync::Arc<crate::ai::DistanceLessThan>),
}

impl Decorator {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeLoop" => Ok(Self::UeLoop(std::sync::Arc::new(crate::ai::UeLoop::new(json)?))),
            "UeCooldown" => Ok(Self::UeCooldown(std::sync::Arc::new(crate::ai::UeCooldown::new(json)?))),
            "UeTimeLimit" => Ok(Self::UeTimeLimit(std::sync::Arc::new(crate::ai::UeTimeLimit::new(json)?))),
            "UeBlackboard" => Ok(Self::UeBlackboard(std::sync::Arc::new(crate::ai::UeBlackboard::new(json)?))),
            "UeForceSuccess" => Ok(Self::UeForceSuccess(std::sync::Arc::new(crate::ai::UeForceSuccess::new(json)?))),
            "IsAtLocation" => Ok(Self::IsAtLocation(std::sync::Arc::new(crate::ai::IsAtLocation::new(json)?))),
            "DistanceLessThan" => Ok(Self::DistanceLessThan(std::sync::Arc::new(crate::ai::DistanceLessThan::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Decorator:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeLoop(x) => { &x.id }
            Self::UeCooldown(x) => { &x.id }
            Self::UeTimeLimit(x) => { &x.id }
            Self::UeBlackboard(x) => { &x.id }
            Self::UeForceSuccess(x) => { &x.id }
            Self::IsAtLocation(x) => { &x.id }
            Self::DistanceLessThan(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeLoop(x) => { &x.node_name }
            Self::UeCooldown(x) => { &x.node_name }
            Self::UeTimeLimit(x) => { &x.node_name }
            Self::UeBlackboard(x) => { &x.node_name }
            Self::UeForceSuccess(x) => { &x.node_name }
            Self::IsAtLocation(x) => { &x.node_name }
            Self::DistanceLessThan(x) => { &x.node_name }
        }
    }    
    
    pub fn get_flow_abort_mode(&self) -> &crate::ai::EFlowAbortMode {
        match self {
            Self::UeLoop(x) => { &x.flow_abort_mode }
            Self::UeCooldown(x) => { &x.flow_abort_mode }
            Self::UeTimeLimit(x) => { &x.flow_abort_mode }
            Self::UeBlackboard(x) => { &x.flow_abort_mode }
            Self::UeForceSuccess(x) => { &x.flow_abort_mode }
            Self::IsAtLocation(x) => { &x.flow_abort_mode }
            Self::DistanceLessThan(x) => { &x.flow_abort_mode }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeLoop(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeLoop as *mut crate::ai::UeLoop); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeCooldown(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeCooldown as *mut crate::ai::UeCooldown); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeTimeLimit(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeTimeLimit as *mut crate::ai::UeTimeLimit); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeBlackboard(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeBlackboard as *mut crate::ai::UeBlackboard); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeForceSuccess(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeForceSuccess as *mut crate::ai::UeForceSuccess); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::IsAtLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::IsAtLocation as *mut crate::ai::IsAtLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DistanceLessThan(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::DistanceLessThan as *mut crate::ai::DistanceLessThan); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct DistanceLessThan {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub actor1_key: String,
    pub actor2_key: String,
    pub distance: f32,
    pub reverse_result: bool,
}

impl DistanceLessThan{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DistanceLessThan, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let actor1_key = json["actor1_key"].as_str().unwrap().to_string();
        let actor2_key = json["actor2_key"].as_str().unwrap().to_string();
        let distance = (json["distance"].as_f64().unwrap() as f32);
        let reverse_result = json["reverse_result"].as_bool().unwrap();
        
        Ok(DistanceLessThan { id, node_name, flow_abort_mode, actor1_key, actor2_key, distance, reverse_result, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct IsAtLocation {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub acceptable_radius: f32,
    pub keyboard_key: String,
    pub inverse_condition: bool,
}

impl IsAtLocation{
    pub(crate) fn new(json: &serde_json::Value) -> Result<IsAtLocation, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let acceptable_radius = (json["acceptable_radius"].as_f64().unwrap() as f32);
        let keyboard_key = json["keyboard_key"].as_str().unwrap().to_string();
        let inverse_condition = json["inverse_condition"].as_bool().unwrap();
        
        Ok(IsAtLocation { id, node_name, flow_abort_mode, acceptable_radius, keyboard_key, inverse_condition, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct UeBlackboard {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub notify_observer: crate::ai::ENotifyObserverMode,
    pub blackboard_key: String,
    pub key_query: crate::ai::KeyQueryOperator,
}

impl UeBlackboard{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeBlackboard, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let notify_observer = json["notify_observer"].as_i64().unwrap().into();
        let blackboard_key = json["blackboard_key"].as_str().unwrap().to_string();
        let key_query = crate::ai::KeyQueryOperator::new(&json["key_query"])?;
        
        Ok(UeBlackboard { id, node_name, flow_abort_mode, notify_observer, blackboard_key, key_query, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.key_query.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct UeCooldown {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub cooldown_time: f32,
}

impl UeCooldown{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeCooldown, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let cooldown_time = (json["cooldown_time"].as_f64().unwrap() as f32);
        
        Ok(UeCooldown { id, node_name, flow_abort_mode, cooldown_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct UeForceSuccess {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
}

impl UeForceSuccess{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeForceSuccess, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        
        Ok(UeForceSuccess { id, node_name, flow_abort_mode, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct UeLoop {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub num_loops: i32,
    pub infinite_loop: bool,
    pub infinite_loop_timeout_time: f32,
}

impl UeLoop{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeLoop, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let num_loops = (json["num_loops"].as_i64().unwrap() as i32);
        let infinite_loop = json["infinite_loop"].as_bool().unwrap();
        let infinite_loop_timeout_time = (json["infinite_loop_timeout_time"].as_f64().unwrap() as f32);
        
        Ok(UeLoop { id, node_name, flow_abort_mode, num_loops, infinite_loop, infinite_loop_timeout_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct UeTimeLimit {
    pub id: i32,
    pub node_name: String,
    pub flow_abort_mode: crate::ai::EFlowAbortMode,
    pub limit_time: f32,
}

impl UeTimeLimit{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeTimeLimit, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let flow_abort_mode = json["flow_abort_mode"].as_i64().unwrap().into();
        let limit_time = (json["limit_time"].as_f64().unwrap() as f32);
        
        Ok(UeTimeLimit { id, node_name, flow_abort_mode, limit_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum FlowNode {
    Sequence(std::sync::Arc<crate::ai::Sequence>),
    Selector(std::sync::Arc<crate::ai::Selector>),
    SimpleParallel(std::sync::Arc<crate::ai::SimpleParallel>),
    UeWait(std::sync::Arc<crate::ai::UeWait>),
    UeWaitBlackboardTime(std::sync::Arc<crate::ai::UeWaitBlackboardTime>),
    MoveToTarget(std::sync::Arc<crate::ai::MoveToTarget>),
    ChooseSkill(std::sync::Arc<crate::ai::ChooseSkill>),
    MoveToRandomLocation(std::sync::Arc<crate::ai::MoveToRandomLocation>),
    MoveToLocation(std::sync::Arc<crate::ai::MoveToLocation>),
    DebugPrint(std::sync::Arc<crate::ai::DebugPrint>),
}

impl FlowNode {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Sequence" => Ok(Self::Sequence(std::sync::Arc::new(crate::ai::Sequence::new(json)?))),
            "Selector" => Ok(Self::Selector(std::sync::Arc::new(crate::ai::Selector::new(json)?))),
            "SimpleParallel" => Ok(Self::SimpleParallel(std::sync::Arc::new(crate::ai::SimpleParallel::new(json)?))),
            "UeWait" => Ok(Self::UeWait(std::sync::Arc::new(crate::ai::UeWait::new(json)?))),
            "UeWaitBlackboardTime" => Ok(Self::UeWaitBlackboardTime(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(json)?))),
            "MoveToTarget" => Ok(Self::MoveToTarget(std::sync::Arc::new(crate::ai::MoveToTarget::new(json)?))),
            "ChooseSkill" => Ok(Self::ChooseSkill(std::sync::Arc::new(crate::ai::ChooseSkill::new(json)?))),
            "MoveToRandomLocation" => Ok(Self::MoveToRandomLocation(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(json)?))),
            "MoveToLocation" => Ok(Self::MoveToLocation(std::sync::Arc::new(crate::ai::MoveToLocation::new(json)?))),
            "DebugPrint" => Ok(Self::DebugPrint(std::sync::Arc::new(crate::ai::DebugPrint::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for FlowNode:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::Sequence(x) => { &x.id }
            Self::Selector(x) => { &x.id }
            Self::SimpleParallel(x) => { &x.id }
            Self::UeWait(x) => { &x.id }
            Self::UeWaitBlackboardTime(x) => { &x.id }
            Self::MoveToTarget(x) => { &x.id }
            Self::ChooseSkill(x) => { &x.id }
            Self::MoveToRandomLocation(x) => { &x.id }
            Self::MoveToLocation(x) => { &x.id }
            Self::DebugPrint(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::Sequence(x) => { &x.node_name }
            Self::Selector(x) => { &x.node_name }
            Self::SimpleParallel(x) => { &x.node_name }
            Self::UeWait(x) => { &x.node_name }
            Self::UeWaitBlackboardTime(x) => { &x.node_name }
            Self::MoveToTarget(x) => { &x.node_name }
            Self::ChooseSkill(x) => { &x.node_name }
            Self::MoveToRandomLocation(x) => { &x.node_name }
            Self::MoveToLocation(x) => { &x.node_name }
            Self::DebugPrint(x) => { &x.node_name }
        }
    }    
    
    pub fn get_decorators(&self) -> &Vec<crate::ai::Decorator> {
        match self {
            Self::Sequence(x) => { &x.decorators }
            Self::Selector(x) => { &x.decorators }
            Self::SimpleParallel(x) => { &x.decorators }
            Self::UeWait(x) => { &x.decorators }
            Self::UeWaitBlackboardTime(x) => { &x.decorators }
            Self::MoveToTarget(x) => { &x.decorators }
            Self::ChooseSkill(x) => { &x.decorators }
            Self::MoveToRandomLocation(x) => { &x.decorators }
            Self::MoveToLocation(x) => { &x.decorators }
            Self::DebugPrint(x) => { &x.decorators }
        }
    }    
    
    pub fn get_services(&self) -> &Vec<crate::ai::Service> {
        match self {
            Self::Sequence(x) => { &x.services }
            Self::Selector(x) => { &x.services }
            Self::SimpleParallel(x) => { &x.services }
            Self::UeWait(x) => { &x.services }
            Self::UeWaitBlackboardTime(x) => { &x.services }
            Self::MoveToTarget(x) => { &x.services }
            Self::ChooseSkill(x) => { &x.services }
            Self::MoveToRandomLocation(x) => { &x.services }
            Self::MoveToLocation(x) => { &x.services }
            Self::DebugPrint(x) => { &x.services }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Sequence(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::Sequence as *mut crate::ai::Sequence); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Selector(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::Selector as *mut crate::ai::Selector); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::SimpleParallel(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::SimpleParallel as *mut crate::ai::SimpleParallel); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWait(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeWait as *mut crate::ai::UeWait); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWaitBlackboardTime(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeWaitBlackboardTime as *mut crate::ai::UeWaitBlackboardTime); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToTarget as *mut crate::ai::MoveToTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseSkill(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::ChooseSkill as *mut crate::ai::ChooseSkill); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToRandomLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToRandomLocation as *mut crate::ai::MoveToRandomLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToLocation as *mut crate::ai::MoveToLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DebugPrint(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::DebugPrint as *mut crate::ai::DebugPrint); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub enum ComposeNode {
    Sequence(std::sync::Arc<crate::ai::Sequence>),
    Selector(std::sync::Arc<crate::ai::Selector>),
    SimpleParallel(std::sync::Arc<crate::ai::SimpleParallel>),
}

impl ComposeNode {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Sequence" => Ok(Self::Sequence(std::sync::Arc::new(crate::ai::Sequence::new(json)?))),
            "Selector" => Ok(Self::Selector(std::sync::Arc::new(crate::ai::Selector::new(json)?))),
            "SimpleParallel" => Ok(Self::SimpleParallel(std::sync::Arc::new(crate::ai::SimpleParallel::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for ComposeNode:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::Sequence(x) => { &x.id }
            Self::Selector(x) => { &x.id }
            Self::SimpleParallel(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::Sequence(x) => { &x.node_name }
            Self::Selector(x) => { &x.node_name }
            Self::SimpleParallel(x) => { &x.node_name }
        }
    }    
    
    pub fn get_decorators(&self) -> &Vec<crate::ai::Decorator> {
        match self {
            Self::Sequence(x) => { &x.decorators }
            Self::Selector(x) => { &x.decorators }
            Self::SimpleParallel(x) => { &x.decorators }
        }
    }    
    
    pub fn get_services(&self) -> &Vec<crate::ai::Service> {
        match self {
            Self::Sequence(x) => { &x.services }
            Self::Selector(x) => { &x.services }
            Self::SimpleParallel(x) => { &x.services }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Sequence(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::Sequence as *mut crate::ai::Sequence); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Selector(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::Selector as *mut crate::ai::Selector); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::SimpleParallel(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::SimpleParallel as *mut crate::ai::SimpleParallel); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct Selector {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub children: Vec<crate::ai::FlowNode>,
}

impl Selector{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Selector, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let children = json["children"].as_array().unwrap().iter().map(|field| crate::ai::FlowNode::new(&field).unwrap()).collect();
        
        Ok(Selector { id, node_name, decorators, services, children, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.children.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct Sequence {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub children: Vec<crate::ai::FlowNode>,
}

impl Sequence{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Sequence, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let children = json["children"].as_array().unwrap().iter().map(|field| crate::ai::FlowNode::new(&field).unwrap()).collect();
        
        Ok(Sequence { id, node_name, decorators, services, children, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.children.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct SimpleParallel {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub finish_mode: crate::ai::EFinishMode,
    pub main_task: crate::ai::Task,
    pub background_node: crate::ai::FlowNode,
}

impl SimpleParallel{
    pub(crate) fn new(json: &serde_json::Value) -> Result<SimpleParallel, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let finish_mode = json["finish_mode"].as_i64().unwrap().into();
        let main_task = crate::ai::Task::new(&json["main_task"])?;
        let background_node = crate::ai::FlowNode::new(&json["background_node"])?;
        
        Ok(SimpleParallel { id, node_name, decorators, services, finish_mode, main_task, background_node, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.main_task.resolve_ref(tables);
        self.background_node.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub enum Task {
    UeWait(std::sync::Arc<crate::ai::UeWait>),
    UeWaitBlackboardTime(std::sync::Arc<crate::ai::UeWaitBlackboardTime>),
    MoveToTarget(std::sync::Arc<crate::ai::MoveToTarget>),
    ChooseSkill(std::sync::Arc<crate::ai::ChooseSkill>),
    MoveToRandomLocation(std::sync::Arc<crate::ai::MoveToRandomLocation>),
    MoveToLocation(std::sync::Arc<crate::ai::MoveToLocation>),
    DebugPrint(std::sync::Arc<crate::ai::DebugPrint>),
}

impl Task {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeWait" => Ok(Self::UeWait(std::sync::Arc::new(crate::ai::UeWait::new(json)?))),
            "UeWaitBlackboardTime" => Ok(Self::UeWaitBlackboardTime(std::sync::Arc::new(crate::ai::UeWaitBlackboardTime::new(json)?))),
            "MoveToTarget" => Ok(Self::MoveToTarget(std::sync::Arc::new(crate::ai::MoveToTarget::new(json)?))),
            "ChooseSkill" => Ok(Self::ChooseSkill(std::sync::Arc::new(crate::ai::ChooseSkill::new(json)?))),
            "MoveToRandomLocation" => Ok(Self::MoveToRandomLocation(std::sync::Arc::new(crate::ai::MoveToRandomLocation::new(json)?))),
            "MoveToLocation" => Ok(Self::MoveToLocation(std::sync::Arc::new(crate::ai::MoveToLocation::new(json)?))),
            "DebugPrint" => Ok(Self::DebugPrint(std::sync::Arc::new(crate::ai::DebugPrint::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Task:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeWait(x) => { &x.id }
            Self::UeWaitBlackboardTime(x) => { &x.id }
            Self::MoveToTarget(x) => { &x.id }
            Self::ChooseSkill(x) => { &x.id }
            Self::MoveToRandomLocation(x) => { &x.id }
            Self::MoveToLocation(x) => { &x.id }
            Self::DebugPrint(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeWait(x) => { &x.node_name }
            Self::UeWaitBlackboardTime(x) => { &x.node_name }
            Self::MoveToTarget(x) => { &x.node_name }
            Self::ChooseSkill(x) => { &x.node_name }
            Self::MoveToRandomLocation(x) => { &x.node_name }
            Self::MoveToLocation(x) => { &x.node_name }
            Self::DebugPrint(x) => { &x.node_name }
        }
    }    
    
    pub fn get_decorators(&self) -> &Vec<crate::ai::Decorator> {
        match self {
            Self::UeWait(x) => { &x.decorators }
            Self::UeWaitBlackboardTime(x) => { &x.decorators }
            Self::MoveToTarget(x) => { &x.decorators }
            Self::ChooseSkill(x) => { &x.decorators }
            Self::MoveToRandomLocation(x) => { &x.decorators }
            Self::MoveToLocation(x) => { &x.decorators }
            Self::DebugPrint(x) => { &x.decorators }
        }
    }    
    
    pub fn get_services(&self) -> &Vec<crate::ai::Service> {
        match self {
            Self::UeWait(x) => { &x.services }
            Self::UeWaitBlackboardTime(x) => { &x.services }
            Self::MoveToTarget(x) => { &x.services }
            Self::ChooseSkill(x) => { &x.services }
            Self::MoveToRandomLocation(x) => { &x.services }
            Self::MoveToLocation(x) => { &x.services }
            Self::DebugPrint(x) => { &x.services }
        }
    }    
    
    pub fn get_ignore_restart_self(&self) -> &bool {
        match self {
            Self::UeWait(x) => { &x.ignore_restart_self }
            Self::UeWaitBlackboardTime(x) => { &x.ignore_restart_self }
            Self::MoveToTarget(x) => { &x.ignore_restart_self }
            Self::ChooseSkill(x) => { &x.ignore_restart_self }
            Self::MoveToRandomLocation(x) => { &x.ignore_restart_self }
            Self::MoveToLocation(x) => { &x.ignore_restart_self }
            Self::DebugPrint(x) => { &x.ignore_restart_self }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeWait(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeWait as *mut crate::ai::UeWait); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UeWaitBlackboardTime(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeWaitBlackboardTime as *mut crate::ai::UeWaitBlackboardTime); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToTarget as *mut crate::ai::MoveToTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseSkill(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::ChooseSkill as *mut crate::ai::ChooseSkill); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToRandomLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToRandomLocation as *mut crate::ai::MoveToRandomLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::MoveToLocation(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::MoveToLocation as *mut crate::ai::MoveToLocation); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DebugPrint(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::DebugPrint as *mut crate::ai::DebugPrint); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct ChooseSkill {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub result_skill_id_key: String,
}

impl ChooseSkill{
    pub(crate) fn new(json: &serde_json::Value) -> Result<ChooseSkill, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let target_actor_key = json["target_actor_key"].as_str().unwrap().to_string();
        let result_skill_id_key = json["result_skill_id_key"].as_str().unwrap().to_string();
        
        Ok(ChooseSkill { id, node_name, decorators, services, ignore_restart_self, target_actor_key, result_skill_id_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct DebugPrint {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub ignore_restart_self: bool,
    pub text: String,
}

impl DebugPrint{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DebugPrint, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let text = json["text"].as_str().unwrap().to_string();
        
        Ok(DebugPrint { id, node_name, decorators, services, ignore_restart_self, text, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct MoveToLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub ignore_restart_self: bool,
    pub acceptable_radius: f32,
}

impl MoveToLocation{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MoveToLocation, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let acceptable_radius = (json["acceptable_radius"].as_f64().unwrap() as f32);
        
        Ok(MoveToLocation { id, node_name, decorators, services, ignore_restart_self, acceptable_radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct MoveToRandomLocation {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub ignore_restart_self: bool,
    pub origin_position_key: String,
    pub radius: f32,
}

impl MoveToRandomLocation{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MoveToRandomLocation, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let origin_position_key = json["origin_position_key"].as_str().unwrap().to_string();
        let radius = (json["radius"].as_f64().unwrap() as f32);
        
        Ok(MoveToRandomLocation { id, node_name, decorators, services, ignore_restart_self, origin_position_key, radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct MoveToTarget {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub ignore_restart_self: bool,
    pub target_actor_key: String,
    pub acceptable_radius: f32,
}

impl MoveToTarget{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MoveToTarget, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let target_actor_key = json["target_actor_key"].as_str().unwrap().to_string();
        let acceptable_radius = (json["acceptable_radius"].as_f64().unwrap() as f32);
        
        Ok(MoveToTarget { id, node_name, decorators, services, ignore_restart_self, target_actor_key, acceptable_radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct UeWait {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub ignore_restart_self: bool,
    pub wait_time: f32,
    pub random_deviation: f32,
}

impl UeWait{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeWait, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let wait_time = (json["wait_time"].as_f64().unwrap() as f32);
        let random_deviation = (json["random_deviation"].as_f64().unwrap() as f32);
        
        Ok(UeWait { id, node_name, decorators, services, ignore_restart_self, wait_time, random_deviation, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct UeWaitBlackboardTime {
    pub id: i32,
    pub node_name: String,
    pub decorators: Vec<crate::ai::Decorator>,
    pub services: Vec<crate::ai::Service>,
    pub ignore_restart_self: bool,
    pub blackboard_key: String,
}

impl UeWaitBlackboardTime{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeWaitBlackboardTime, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let decorators = json["decorators"].as_array().unwrap().iter().map(|field| crate::ai::Decorator::new(&field).unwrap()).collect();
        let services = json["services"].as_array().unwrap().iter().map(|field| crate::ai::Service::new(&field).unwrap()).collect();
        let ignore_restart_self = json["ignore_restart_self"].as_bool().unwrap();
        let blackboard_key = json["blackboard_key"].as_str().unwrap().to_string();
        
        Ok(UeWaitBlackboardTime { id, node_name, decorators, services, ignore_restart_self, blackboard_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.decorators.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.services.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub enum Service {
    UeSetDefaultFocus(std::sync::Arc<crate::ai::UeSetDefaultFocus>),
    ExecuteTimeStatistic(std::sync::Arc<crate::ai::ExecuteTimeStatistic>),
    ChooseTarget(std::sync::Arc<crate::ai::ChooseTarget>),
    KeepFaceTarget(std::sync::Arc<crate::ai::KeepFaceTarget>),
    GetOwnerPlayer(std::sync::Arc<crate::ai::GetOwnerPlayer>),
    UpdateDailyBehaviorProps(std::sync::Arc<crate::ai::UpdateDailyBehaviorProps>),
}

impl Service {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "UeSetDefaultFocus" => Ok(Self::UeSetDefaultFocus(std::sync::Arc::new(crate::ai::UeSetDefaultFocus::new(json)?))),
            "ExecuteTimeStatistic" => Ok(Self::ExecuteTimeStatistic(std::sync::Arc::new(crate::ai::ExecuteTimeStatistic::new(json)?))),
            "ChooseTarget" => Ok(Self::ChooseTarget(std::sync::Arc::new(crate::ai::ChooseTarget::new(json)?))),
            "KeepFaceTarget" => Ok(Self::KeepFaceTarget(std::sync::Arc::new(crate::ai::KeepFaceTarget::new(json)?))),
            "GetOwnerPlayer" => Ok(Self::GetOwnerPlayer(std::sync::Arc::new(crate::ai::GetOwnerPlayer::new(json)?))),
            "UpdateDailyBehaviorProps" => Ok(Self::UpdateDailyBehaviorProps(std::sync::Arc::new(crate::ai::UpdateDailyBehaviorProps::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Service:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.id }
            Self::ExecuteTimeStatistic(x) => { &x.id }
            Self::ChooseTarget(x) => { &x.id }
            Self::KeepFaceTarget(x) => { &x.id }
            Self::GetOwnerPlayer(x) => { &x.id }
            Self::UpdateDailyBehaviorProps(x) => { &x.id }
        }
    }    
    
    pub fn get_node_name(&self) -> &String {
        match self {
            Self::UeSetDefaultFocus(x) => { &x.node_name }
            Self::ExecuteTimeStatistic(x) => { &x.node_name }
            Self::ChooseTarget(x) => { &x.node_name }
            Self::KeepFaceTarget(x) => { &x.node_name }
            Self::GetOwnerPlayer(x) => { &x.node_name }
            Self::UpdateDailyBehaviorProps(x) => { &x.node_name }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::UeSetDefaultFocus(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UeSetDefaultFocus as *mut crate::ai::UeSetDefaultFocus); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ExecuteTimeStatistic(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::ExecuteTimeStatistic as *mut crate::ai::ExecuteTimeStatistic); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::ChooseTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::ChooseTarget as *mut crate::ai::ChooseTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::KeepFaceTarget(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::KeepFaceTarget as *mut crate::ai::KeepFaceTarget); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::GetOwnerPlayer(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::GetOwnerPlayer as *mut crate::ai::GetOwnerPlayer); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::UpdateDailyBehaviorProps(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const crate::ai::UpdateDailyBehaviorProps as *mut crate::ai::UpdateDailyBehaviorProps); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct ChooseTarget {
    pub id: i32,
    pub node_name: String,
    pub result_target_key: String,
}

impl ChooseTarget{
    pub(crate) fn new(json: &serde_json::Value) -> Result<ChooseTarget, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let result_target_key = json["result_target_key"].as_str().unwrap().to_string();
        
        Ok(ChooseTarget { id, node_name, result_target_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct ExecuteTimeStatistic {
    pub id: i32,
    pub node_name: String,
}

impl ExecuteTimeStatistic{
    pub(crate) fn new(json: &serde_json::Value) -> Result<ExecuteTimeStatistic, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        
        Ok(ExecuteTimeStatistic { id, node_name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct GetOwnerPlayer {
    pub id: i32,
    pub node_name: String,
    pub player_actor_key: String,
}

impl GetOwnerPlayer{
    pub(crate) fn new(json: &serde_json::Value) -> Result<GetOwnerPlayer, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let player_actor_key = json["player_actor_key"].as_str().unwrap().to_string();
        
        Ok(GetOwnerPlayer { id, node_name, player_actor_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct KeepFaceTarget {
    pub id: i32,
    pub node_name: String,
    pub target_actor_key: String,
}

impl KeepFaceTarget{
    pub(crate) fn new(json: &serde_json::Value) -> Result<KeepFaceTarget, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let target_actor_key = json["target_actor_key"].as_str().unwrap().to_string();
        
        Ok(KeepFaceTarget { id, node_name, target_actor_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct UeSetDefaultFocus {
    pub id: i32,
    pub node_name: String,
    pub keyboard_key: String,
}

impl UeSetDefaultFocus{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UeSetDefaultFocus, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let keyboard_key = json["keyboard_key"].as_str().unwrap().to_string();
        
        Ok(UeSetDefaultFocus { id, node_name, keyboard_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct UpdateDailyBehaviorProps {
    pub id: i32,
    pub node_name: String,
    pub satiety_key: String,
    pub energy_key: String,
    pub mood_key: String,
    pub satiety_lower_threshold_key: String,
    pub satiety_upper_threshold_key: String,
    pub energy_lower_threshold_key: String,
    pub energy_upper_threshold_key: String,
    pub mood_lower_threshold_key: String,
    pub mood_upper_threshold_key: String,
}

impl UpdateDailyBehaviorProps{
    pub(crate) fn new(json: &serde_json::Value) -> Result<UpdateDailyBehaviorProps, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let node_name = json["node_name"].as_str().unwrap().to_string();
        let satiety_key = json["satiety_key"].as_str().unwrap().to_string();
        let energy_key = json["energy_key"].as_str().unwrap().to_string();
        let mood_key = json["mood_key"].as_str().unwrap().to_string();
        let satiety_lower_threshold_key = json["satiety_lower_threshold_key"].as_str().unwrap().to_string();
        let satiety_upper_threshold_key = json["satiety_upper_threshold_key"].as_str().unwrap().to_string();
        let energy_lower_threshold_key = json["energy_lower_threshold_key"].as_str().unwrap().to_string();
        let energy_upper_threshold_key = json["energy_upper_threshold_key"].as_str().unwrap().to_string();
        let mood_lower_threshold_key = json["mood_lower_threshold_key"].as_str().unwrap().to_string();
        let mood_upper_threshold_key = json["mood_upper_threshold_key"].as_str().unwrap().to_string();
        
        Ok(UpdateDailyBehaviorProps { id, node_name, satiety_key, energy_key, mood_key, satiety_lower_threshold_key, satiety_upper_threshold_key, energy_lower_threshold_key, energy_upper_threshold_key, mood_lower_threshold_key, mood_upper_threshold_key, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}


#[derive(Debug)]
pub struct TbBlackboard {
    pub data_list: Vec<std::sync::Arc<crate::ai::Blackboard>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<crate::ai::Blackboard>>,
}

impl TbBlackboard {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbBlackboard>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<crate::ai::Blackboard>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::ai::Blackboard>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::ai::Blackboard::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.name.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBlackboard { data_map, data_list }))
    }

    pub fn get(&self, key: &str) -> Option<std::sync::Arc<crate::ai::Blackboard>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::ai::Blackboard as *mut crate::ai::Blackboard); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<String> for TbBlackboard {
    type Output = std::sync::Arc<crate::ai::Blackboard>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbBehaviorTree {
    pub data_list: Vec<std::sync::Arc<crate::ai::BehaviorTree>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<crate::ai::BehaviorTree>>,
}

impl TbBehaviorTree {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbBehaviorTree>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<crate::ai::BehaviorTree>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<crate::ai::BehaviorTree>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(crate::ai::BehaviorTree::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbBehaviorTree { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<crate::ai::BehaviorTree>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const crate::ai::BehaviorTree as *mut crate::ai::BehaviorTree); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbBehaviorTree {
    type Output = std::sync::Arc<crate::ai::BehaviorTree>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


