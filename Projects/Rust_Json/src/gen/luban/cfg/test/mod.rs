
/*!
<auto-generated>
    This code was generated by a tool.
    Changes to this file may cause incorrect behavior and will be lost if
    the code is regenerated.
</auto-generated>
*/

pub mod login;

use super::*;
use serde::Deserialize;

bitflags::bitflags! {    
    #[derive(Debug, Hash, Eq, PartialEq)]
    pub struct AccessFlag : u32 {
        const WRITE = 1;
        const READ = 2;
        const TRUNCATE = 4;
        const NEW = 8;
        const READ_WRITE = 3;
    }
}
#[derive(Deserialize, Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum AudioType2 {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
}

impl From<i32> for AudioType2 {
    fn from(value: i32) -> Self {
        match value {
            0 => AudioType2::UNKNOWN,
            1 => AudioType2::ACC,
            2 => AudioType2::AIFF,
            _ => panic!("Invalid value for AudioType2:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum DemoEnum {
    NONE = 0,
    ///aa
    A = 1,
    ///bb
    B = 2,
    ///cc
    C = 4,
    ///dd
    D = 5,
    Any = 6,
}

impl From<i32> for DemoEnum {
    fn from(value: i32) -> Self {
        match value {
            0 => DemoEnum::NONE,
            1 => DemoEnum::A,
            2 => DemoEnum::B,
            4 => DemoEnum::C,
            5 => DemoEnum::D,
            6 => DemoEnum::Any,
            _ => panic!("Invalid value for DemoEnum:{}", value),
        }
    }
}

bitflags::bitflags! {    
    #[derive(Debug, Hash, Eq, PartialEq)]
    pub struct DemoFlag : u32 {
        const A = 1;
        const B = 2;
        const C = 4;
        const D = 8;
    }
}
#[derive(Deserialize, Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum ETestEmptyEnum {
    None
}

impl From<i32> for ETestEmptyEnum {
    fn from(value: i32) -> Self {
        match value {
            _ => panic!("Invalid value for ETestEmptyEnum:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum ETestEmptyEnum2 {
    SMALL_THAN_256 = 255,
    X_256 = 256,
    X_257 = 257,
}

impl From<i32> for ETestEmptyEnum2 {
    fn from(value: i32) -> Self {
        match value {
            255 => ETestEmptyEnum2::SMALL_THAN_256,
            256 => ETestEmptyEnum2::X_256,
            257 => ETestEmptyEnum2::X_257,
            _ => panic!("Invalid value for ETestEmptyEnum2:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum ETestQuality {
    ///最高品质
    A = 1,
    ///黑色的
    B = 2,
    ///蓝色的
    C = 3,
    ///最差品质
    D = 4,
}

impl From<i32> for ETestQuality {
    fn from(value: i32) -> Self {
        match value {
            1 => ETestQuality::A,
            2 => ETestQuality::B,
            3 => ETestQuality::C,
            4 => ETestQuality::D,
            _ => panic!("Invalid value for ETestQuality:{}", value),
        }
    }
}

#[derive(Deserialize, Debug, Hash, Eq, PartialEq, luban_macros::EnumFromNum)]
pub enum ETestUeType {
    ///白
    WHITE = 0,
    BLACK = 1,
}

impl From<i32> for ETestUeType {
    fn from(value: i32) -> Self {
        match value {
            0 => ETestUeType::WHITE,
            1 => ETestUeType::BLACK,
            _ => panic!("Invalid value for ETestUeType:{}", value),
        }
    }
}

#[derive(Debug)]
pub struct AutoImport2 {
    /// 这是id
    pub id: i32,
    /// 字段x1
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub x8: i32,
    pub x10: String,
    pub x13: test::DemoEnum,
    pub x13_2: test::DemoFlag,
    pub x14: test::DemoDynamic,
    pub x15: test::Shape,
    pub v2: crate::Vec2,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<test::DemoE2>,
    pub k10: Vec<crate::Vec3>,
    pub k11: Vec<crate::Vec4>,
    pub v11: Option<crate::Vec3>,
}

impl AutoImport2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<AutoImport2, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_bool().unwrap();
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let x8 = (json["x8"].as_i64().unwrap() as i32);
        let x10 = json["x10"].as_str().unwrap().to_string();
        let x13 = Into::<test::DemoEnum>::into(json["x13"].as_i64().unwrap());
        let x13_2 = test::DemoFlag::from_bits_truncate(<u32 as std::str::FromStr>::from_str(&json["x13_2"].to_string()).unwrap());
        let x14 = test::DemoDynamic::new(&json["x14"])?;
        let x15 = test::Shape::new(&json["x15"])?;
        let v2 = vec2::new(&json["v2"])?.into();
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k2 = json["k2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| test::DemoE2::new(&field).unwrap()).collect();
        let k10 = json["k10"].as_array().unwrap().iter().map(|field| vec3::new(&field).unwrap().into()).collect();
        let k11 = json["k11"].as_array().unwrap().iter().map(|field| vec4::new(&field).unwrap().into()).collect();
        let mut v11 = None; if let Some(value) = json.get("v11") { v11 = Some(vec3::new(&json["v11"])?.into()); }
        
        Ok(AutoImport2 { id, x1, x5, x6, x8, x10, x13, x13_2, x14, x15, v2, t1, k1, k2, k8, k9, k10, k11, v11, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x14.resolve_ref(tables);
        self.x15.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct CompactString {
    pub id: i32,
    pub s2: String,
    pub s3: String,
}

impl CompactString{
    pub(crate) fn new(json: &serde_json::Value) -> Result<CompactString, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let s2 = json["s2"].as_str().unwrap().to_string();
        let s3 = json["s3"].as_str().unwrap().to_string();
        
        Ok(CompactString { id, s2, s3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct CompositeJsonTable1 {
    pub id: i32,
    pub x: String,
}

impl CompositeJsonTable1{
    pub(crate) fn new(json: &serde_json::Value) -> Result<CompositeJsonTable1, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = json["x"].as_str().unwrap().to_string();
        
        Ok(CompositeJsonTable1 { id, x, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct CompositeJsonTable2 {
    pub id: i32,
    pub y: i32,
}

impl CompositeJsonTable2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<CompositeJsonTable2, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        
        Ok(CompositeJsonTable2 { id, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct CompositeJsonTable3 {
    pub a: i32,
    pub b: i32,
}

impl CompositeJsonTable3{
    pub(crate) fn new(json: &serde_json::Value) -> Result<CompositeJsonTable3, LubanError> {
        let a = (json["a"].as_i64().unwrap() as i32);
        let b = (json["b"].as_i64().unwrap() as i32);
        
        Ok(CompositeJsonTable3 { a, b, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct DateTimeRange {
    pub start_time: u64,
    pub end_time: u64,
}

impl DateTimeRange{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DateTimeRange, LubanError> {
        let start_time = (json["start_time"].as_i64().unwrap() as u64);
        let end_time = (json["end_time"].as_i64().unwrap() as u64);
        
        Ok(DateTimeRange { start_time, end_time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct DefineFromExcel2 {
    /// 这是id
    pub id: i32,
    /// 字段x1
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub x8: i32,
    pub x10: String,
    pub x13: test::DemoEnum,
    pub x13_2: test::DemoFlag,
    pub x13_3: test::DemoFlag,
    pub x14: test::DemoDynamic,
    pub x15: test::Shape,
    pub v2: crate::Vec2,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<test::DemoE2>,
    pub k10: Vec<crate::Vec3>,
    pub k11: Vec<crate::Vec4>,
    pub v11: Option<crate::Vec3>,
}

impl DefineFromExcel2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DefineFromExcel2, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_bool().unwrap();
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let x8 = (json["x8"].as_i64().unwrap() as i32);
        let x10 = json["x10"].as_str().unwrap().to_string();
        let x13 = Into::<test::DemoEnum>::into(json["x13"].as_i64().unwrap());
        let x13_2 = test::DemoFlag::from_bits_truncate(<u32 as std::str::FromStr>::from_str(&json["x13_2"].to_string()).unwrap());
        let x13_3 = test::DemoFlag::from_bits_truncate(<u32 as std::str::FromStr>::from_str(&json["x13_3"].to_string()).unwrap());
        let x14 = test::DemoDynamic::new(&json["x14"])?;
        let x15 = test::Shape::new(&json["x15"])?;
        let v2 = vec2::new(&json["v2"])?.into();
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k2 = json["k2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| test::DemoE2::new(&field).unwrap()).collect();
        let k10 = json["k10"].as_array().unwrap().iter().map(|field| vec3::new(&field).unwrap().into()).collect();
        let k11 = json["k11"].as_array().unwrap().iter().map(|field| vec4::new(&field).unwrap().into()).collect();
        let mut v11 = None; if let Some(value) = json.get("v11") { v11 = Some(vec3::new(&json["v11"])?.into()); }
        
        Ok(DefineFromExcel2 { id, x1, x5, x6, x8, x10, x13, x13_2, x13_3, x14, x15, v2, t1, k1, k2, k8, k9, k10, k11, v11, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x14.resolve_ref(tables);
        self.x15.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub enum DemoDynamic {
    DemoD2(std::sync::Arc<test::DemoD2>),
    DemoE1(std::sync::Arc<test::DemoE1>),
    RoleInfo(std::sync::Arc<test::login::RoleInfo>),
    DemoD5(std::sync::Arc<test::DemoD5>),
}

impl DemoDynamic {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "DemoD2" => Ok(Self::DemoD2(std::sync::Arc::new(test::DemoD2::new(json)?))),
            "DemoE1" => Ok(Self::DemoE1(std::sync::Arc::new(test::DemoE1::new(json)?))),
            "test.login.RoleInfo" => Ok(Self::RoleInfo(std::sync::Arc::new(test::login::RoleInfo::new(json)?))),
            "DemoD5" => Ok(Self::DemoD5(std::sync::Arc::new(test::DemoD5::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoDynamic:{}", type_id)))
        }
    }
    
    pub fn get_x1(&self) -> &i32 {
        match self {
            Self::DemoD2(x) => { &x.x1 }
            Self::DemoE1(x) => { &x.x1 }
            Self::RoleInfo(x) => { &x.x1 }
            Self::DemoD5(x) => { &x.x1 }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::DemoD2(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::DemoD2 as *mut test::DemoD2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DemoE1(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::DemoE1 as *mut test::DemoE1); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::RoleInfo(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::login::RoleInfo as *mut test::login::RoleInfo); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::DemoD5(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::DemoD5 as *mut test::DemoD5); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct DemoD2 {
    pub x1: i32,
    pub x2: i32,
}

impl DemoD2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoD2, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x2 = (json["x2"].as_i64().unwrap() as i32);
        
        Ok(DemoD2 { x1, x2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum DemoD3 {
    DemoE1(std::sync::Arc<test::DemoE1>),
    RoleInfo(std::sync::Arc<test::login::RoleInfo>),
}

impl DemoD3 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "DemoE1" => Ok(Self::DemoE1(std::sync::Arc::new(test::DemoE1::new(json)?))),
            "test.login.RoleInfo" => Ok(Self::RoleInfo(std::sync::Arc::new(test::login::RoleInfo::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for DemoD3:{}", type_id)))
        }
    }
    
    pub fn get_x1(&self) -> &i32 {
        match self {
            Self::DemoE1(x) => { &x.x1 }
            Self::RoleInfo(x) => { &x.x1 }
        }
    }    
    
    pub fn get_x3(&self) -> &i32 {
        match self {
            Self::DemoE1(x) => { &x.x3 }
            Self::RoleInfo(x) => { &x.x3 }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::DemoE1(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::DemoE1 as *mut test::DemoE1); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::RoleInfo(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::login::RoleInfo as *mut test::login::RoleInfo); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct DemoE1 {
    pub x1: i32,
    pub x3: i32,
    pub x4: i32,
}

impl DemoE1{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoE1, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        
        Ok(DemoE1 { x1, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct DemoD5 {
    pub x1: i32,
    pub time: test::DateTimeRange,
}

impl DemoD5{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoD5, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let time = test::DateTimeRange::new(&json["time"])?;
        
        Ok(DemoD5 { x1, time, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.time.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct DemoE2 {
    pub y1: Option<i32>,
    pub y2: bool,
}

impl DemoE2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoE2, LubanError> {
        let mut y1 = None; if let Some(value) = json.get("y1") { y1 = Some((json["y1"].as_i64().unwrap() as i32)); }
        let y2 = json["y2"].as_bool().unwrap();
        
        Ok(DemoE2 { y1, y2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct DemoExplicitType {
    pub x1: u8,
    pub x2: i16,
    pub x3: i32,
    pub x4: i64,
    pub x5: f32,
    pub x6: f64,
    pub x7: i64,
}

impl DemoExplicitType{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoExplicitType, LubanError> {
        let x1 = (json["x1"].as_u64().unwrap() as u8);
        let x2 = (json["x2"].as_i64().unwrap() as i16);
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = json["x4"].as_i64().unwrap();
        let x5 = (json["x5"].as_f64().unwrap() as f32);
        let x6 = json["x6"].as_f64().unwrap();
        let x7 = json["x7"].as_i64().unwrap();
        
        Ok(DemoExplicitType { x1, x2, x3, x4, x5, x6, x7, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct DemoGroup {
    pub id: i32,
    pub x1: i32,
    pub x1_ref: Option<std::sync::Arc<test::DemoGroup>>,
    pub x2: i32,
    pub x2_ref: Option<std::sync::Arc<test::DemoGroup>>,
    pub x3: i32,
    pub x3_ref: Option<std::sync::Arc<test::DemoGroup>>,
    pub x4: i32,
    pub x5: test::InnerGroup,
}

impl DemoGroup{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoGroup, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x1_ref = None;
        let x2 = (json["x2"].as_i64().unwrap() as i32);
        let x2_ref = None;
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x3_ref = None;
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x5 = test::InnerGroup::new(&json["x5"])?;
        
        Ok(DemoGroup { id, x1, x1_ref, x2, x2_ref, x3, x3_ref, x4, x5, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x1_ref = tables.TbDemoGroup_C.get(&self.x1);
        self.x2_ref = tables.TbDemoGroup_S.get(&self.x2);
        self.x3_ref = tables.TbDemoGroup_E.get(&self.x3);
        self.x5.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct DemoPrimitiveTypesTable {
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x4: i32,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub s1: String,
    pub s2: String,
    pub v2: crate::Vec2,
    pub v3: crate::Vec3,
    pub v4: crate::Vec4,
    pub t1: u64,
}

impl DemoPrimitiveTypesTable{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoPrimitiveTypesTable, LubanError> {
        let x1 = json["x1"].as_bool().unwrap();
        let x2 = (json["x2"].as_u64().unwrap() as u8);
        let x3 = (json["x3"].as_i64().unwrap() as i16);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let x7 = json["x7"].as_f64().unwrap();
        let s1 = json["s1"].as_str().unwrap().to_string();
        let s2 = json["s2"].as_str().unwrap().to_string();
        let v2 = vec2::new(&json["v2"])?.into();
        let v3 = vec3::new(&json["v3"])?.into();
        let v4 = vec4::new(&json["v4"])?.into();
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        
        Ok(DemoPrimitiveTypesTable { x1, x2, x3, x4, x5, x6, x7, s1, s2, v2, v3, v4, t1, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct DemoSingletonType {
    pub id: i32,
    pub name: String,
    pub date: test::DemoDynamic,
}

impl DemoSingletonType{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoSingletonType, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let date = test::DemoDynamic::new(&json["date"])?;
        
        Ok(DemoSingletonType { id, name, date, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.date.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct DemoType1 {
    pub x1: i32,
}

impl DemoType1{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoType1, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        
        Ok(DemoType1 { x1, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct DemoType2 {
    pub x4: i32,
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x5: i64,
    pub x6: f32,
    pub x7: f64,
    pub x8_0: i16,
    pub x8: i32,
    pub x9: i64,
    pub x10: String,
    pub x12: test::DemoType1,
    pub x13: test::DemoEnum,
    pub x14: test::DemoDynamic,
    pub s1: String,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k5: std::collections::HashSet<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k8_ref: Option<std::sync::Arc<std::collections::HashMap<i32, Option<std::sync::Arc<test::DemoType2>>>>>,
    pub k9: Vec<test::DemoE2>,
    pub k15: Vec<test::DemoDynamic>,
}

impl DemoType2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DemoType2, LubanError> {
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_bool().unwrap();
        let x2 = (json["x2"].as_u64().unwrap() as u8);
        let x3 = (json["x3"].as_i64().unwrap() as i16);
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let x7 = json["x7"].as_f64().unwrap();
        let x8_0 = (json["x8_0"].as_i64().unwrap() as i16);
        let x8 = (json["x8"].as_i64().unwrap() as i32);
        let x9 = json["x9"].as_i64().unwrap();
        let x10 = json["x10"].as_str().unwrap().to_string();
        let x12 = test::DemoType1::new(&json["x12"])?;
        let x13 = Into::<test::DemoEnum>::into(json["x13"].as_i64().unwrap());
        let x14 = test::DemoDynamic::new(&json["x14"])?;
        let s1 = json["s1"].as_str().unwrap().to_string();
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k2 = json["k2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k5 = json["k5"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let k8_ref = None;
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| test::DemoE2::new(&field).unwrap()).collect();
        let k15 = json["k15"].as_array().unwrap().iter().map(|field| test::DemoDynamic::new(&field).unwrap()).collect();
        
        Ok(DemoType2 { x4, x1, x2, x3, x5, x6, x7, x8_0, x8, x9, x10, x12, x13, x14, s1, t1, k1, k2, k5, k8, k8_ref, k9, k15, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x12.resolve_ref(tables);
        self.x14.resolve_ref(tables);
        self.k8_ref = Some(std::sync::Arc::new(self.k8.iter().map(|x| (x.0.clone(), tables.TbFullTypes.get(x.1))).collect()));
        self.k15.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct DetectEncoding {
    pub id: i32,
    pub name: String,
}

impl DetectEncoding{
    pub(crate) fn new(json: &serde_json::Value) -> Result<DetectEncoding, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        
        Ok(DetectEncoding { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct ExcelFromJson {
    pub x4: i32,
    pub x1: bool,
    pub x5: i64,
    pub x6: f32,
    pub s1: String,
    pub s2: String,
    pub t1: u64,
    pub x12: test::DemoType1,
    pub x13: test::DemoEnum,
    pub x14: test::DemoDynamic,
    pub k1: Vec<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<test::DemoE2>,
    pub k15: Vec<test::DemoDynamic>,
}

impl ExcelFromJson{
    pub(crate) fn new(json: &serde_json::Value) -> Result<ExcelFromJson, LubanError> {
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_bool().unwrap();
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let s1 = json["s1"].as_str().unwrap().to_string();
        let s2 = json["s2"].as_str().unwrap().to_string();
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        let x12 = test::DemoType1::new(&json["x12"])?;
        let x13 = Into::<test::DemoEnum>::into(json["x13"].as_i64().unwrap());
        let x14 = test::DemoDynamic::new(&json["x14"])?;
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| test::DemoE2::new(&field).unwrap()).collect();
        let k15 = json["k15"].as_array().unwrap().iter().map(|field| test::DemoDynamic::new(&field).unwrap()).collect();
        
        Ok(ExcelFromJson { x4, x1, x5, x6, s1, s2, t1, x12, x13, x14, k1, k8, k9, k15, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x12.resolve_ref(tables);
        self.x14.resolve_ref(tables);
        self.k15.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct ExcelFromJsonMultiRow {
    pub id: i32,
    pub x: i32,
    pub items: Vec<test::TestRow>,
}

impl ExcelFromJsonMultiRow{
    pub(crate) fn new(json: &serde_json::Value) -> Result<ExcelFromJsonMultiRow, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = (json["x"].as_i64().unwrap() as i32);
        let items = json["items"].as_array().unwrap().iter().map(|field| test::TestRow::new(&field).unwrap()).collect();
        
        Ok(ExcelFromJsonMultiRow { id, x, items, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.items.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct Foo {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
}

impl Foo{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Foo, LubanError> {
        let y1 = (json["y1"].as_i64().unwrap() as i32);
        let y2 = (json["y2"].as_i64().unwrap() as i32);
        let y3 = (json["y3"].as_i64().unwrap() as i32);
        
        Ok(Foo { y1, y2, y3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct H1 {
    pub y2: test::H2,
    pub y3: i32,
}

impl H1{
    pub(crate) fn new(json: &serde_json::Value) -> Result<H1, LubanError> {
        let y2 = test::H2::new(&json["y2"])?;
        let y3 = (json["y3"].as_i64().unwrap() as i32);
        
        Ok(H1 { y2, y3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.y2.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct H2 {
    pub z2: i32,
    pub z3: i32,
}

impl H2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<H2, LubanError> {
        let z2 = (json["z2"].as_i64().unwrap() as i32);
        let z3 = (json["z3"].as_i64().unwrap() as i32);
        
        Ok(H2 { z2, z3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct InnerGroup {
    pub y1: i32,
    pub y2: i32,
    pub y3: i32,
    pub y4: i32,
}

impl InnerGroup{
    pub(crate) fn new(json: &serde_json::Value) -> Result<InnerGroup, LubanError> {
        let y1 = (json["y1"].as_i64().unwrap() as i32);
        let y2 = (json["y2"].as_i64().unwrap() as i32);
        let y3 = (json["y3"].as_i64().unwrap() as i32);
        let y4 = (json["y4"].as_i64().unwrap() as i32);
        
        Ok(InnerGroup { y1, y2, y3, y4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum ItemBase {
    Item(std::sync::Arc<test::Item>),
    Equipment(std::sync::Arc<test::Equipment>),
    Decorator(std::sync::Arc<test::Decorator>),
}

impl ItemBase {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Item" => Ok(Self::Item(std::sync::Arc::new(test::Item::new(json)?))),
            "Equipment" => Ok(Self::Equipment(std::sync::Arc::new(test::Equipment::new(json)?))),
            "Decorator" => Ok(Self::Decorator(std::sync::Arc::new(test::Decorator::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for ItemBase:{}", type_id)))
        }
    }
    
    pub fn get_id(&self) -> &i32 {
        match self {
            Self::Item(x) => { &x.id }
            Self::Equipment(x) => { &x.id }
            Self::Decorator(x) => { &x.id }
        }
    }    
    
    pub fn get_name(&self) -> &String {
        match self {
            Self::Item(x) => { &x.name }
            Self::Equipment(x) => { &x.name }
            Self::Decorator(x) => { &x.name }
        }
    }    
    
    pub fn get_desc(&self) -> &String {
        match self {
            Self::Item(x) => { &x.desc }
            Self::Equipment(x) => { &x.desc }
            Self::Decorator(x) => { &x.desc }
        }
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Item(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::Item as *mut test::Item); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Equipment(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::Equipment as *mut test::Equipment); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Decorator(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::Decorator as *mut test::Decorator); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct Decorator {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub duration: i32,
}

impl Decorator{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Decorator, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let duration = (json["duration"].as_i64().unwrap() as i32);
        
        Ok(Decorator { id, name, desc, duration, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct Equipment {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub attr: test::DemoEnum,
    pub value: i32,
}

impl Equipment{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Equipment, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let attr = Into::<test::DemoEnum>::into(json["attr"].as_i64().unwrap());
        let value = (json["value"].as_i64().unwrap() as i32);
        
        Ok(Equipment { id, name, desc, attr, value, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct Item {
    pub id: i32,
    pub name: String,
    pub desc: String,
    pub num: i32,
    pub price: i32,
}

impl Item{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Item, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let desc = json["desc"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let price = (json["price"].as_i64().unwrap() as i32);
        
        Ok(Item { id, name, desc, num, price, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct MultiIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiIndexList{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MultiIndexList, LubanError> {
        let id1 = (json["id1"].as_i64().unwrap() as i32);
        let id2 = json["id2"].as_i64().unwrap();
        let id3 = json["id3"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        
        Ok(MultiIndexList { id1, id2, id3, num, desc, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct MultiRowRecord {
    pub id: i32,
    pub name: String,
    pub one_rows: Vec<test::MultiRowType1>,
    pub multi_rows1: Vec<test::MultiRowType1>,
    pub multi_rows2: Vec<test::MultiRowType1>,
    pub multi_rows4: std::collections::HashMap<i32, test::MultiRowType2>,
    pub multi_rows5: Vec<test::MultiRowType3>,
    pub multi_rows6: std::collections::HashMap<i32, test::MultiRowType2>,
    pub multi_rows7: std::collections::HashMap<i32, i32>,
}

impl MultiRowRecord{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MultiRowRecord, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let one_rows = json["one_rows"].as_array().unwrap().iter().map(|field| test::MultiRowType1::new(&field).unwrap()).collect();
        let multi_rows1 = json["multi_rows1"].as_array().unwrap().iter().map(|field| test::MultiRowType1::new(&field).unwrap()).collect();
        let multi_rows2 = json["multi_rows2"].as_array().unwrap().iter().map(|field| test::MultiRowType1::new(&field).unwrap()).collect();
        let multi_rows4 = std::collections::HashMap::from_iter(json["multi_rows4"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), test::MultiRowType2::new(&array[1]).unwrap())}).collect::<Vec<(i32, test::MultiRowType2)>>());
        let multi_rows5 = json["multi_rows5"].as_array().unwrap().iter().map(|field| test::MultiRowType3::new(&field).unwrap()).collect();
        let multi_rows6 = std::collections::HashMap::from_iter(json["multi_rows6"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), test::MultiRowType2::new(&array[1]).unwrap())}).collect::<Vec<(i32, test::MultiRowType2)>>());
        let multi_rows7 = std::collections::HashMap::from_iter(json["multi_rows7"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        
        Ok(MultiRowRecord { id, name, one_rows, multi_rows1, multi_rows2, multi_rows4, multi_rows5, multi_rows6, multi_rows7, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.one_rows.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows1.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows2.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows4.values_mut().for_each(|x| { x.resolve_ref(tables) });
        self.multi_rows5.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.multi_rows6.values_mut().for_each(|x| { x.resolve_ref(tables) });
    }
}

#[derive(Debug)]
pub struct MultiRowTitle {
    pub id: i32,
    pub name: String,
    pub x1: test::H1,
    pub x2_0: Option<test::H2>,
    pub x2: Vec<test::H2>,
    pub x3: Vec<test::H2>,
    pub x4: Vec<test::H2>,
}

impl MultiRowTitle{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MultiRowTitle, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        let x1 = test::H1::new(&json["x1"])?;
        let mut x2_0 = None; if let Some(value) = json.get("x2_0") { x2_0 = Some(test::H2::new(&json["x2_0"])?); }
        let x2 = json["x2"].as_array().unwrap().iter().map(|field| test::H2::new(&field).unwrap()).collect();
        let x3 = json["x3"].as_array().unwrap().iter().map(|field| test::H2::new(&field).unwrap()).collect();
        let x4 = json["x4"].as_array().unwrap().iter().map(|field| test::H2::new(&field).unwrap()).collect();
        
        Ok(MultiRowTitle { id, name, x1, x2_0, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x1.resolve_ref(tables);
        if let Some(x) = &mut self.x2_0 { x.resolve_ref(tables); }
        self.x2.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.x3.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
        self.x4.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct MultiRowType1 {
    pub id: i32,
    pub x: i32,
}

impl MultiRowType1{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MultiRowType1, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = (json["x"].as_i64().unwrap() as i32);
        
        Ok(MultiRowType1 { id, x, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct MultiRowType2 {
    pub id: i32,
    pub x: i32,
    pub y: f32,
}

impl MultiRowType2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MultiRowType2, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_f64().unwrap() as f32);
        
        Ok(MultiRowType2 { id, x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct MultiRowType3 {
    pub id: i32,
    pub items: Vec<test::MultiRowType1>,
}

impl MultiRowType3{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MultiRowType3, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let items = json["items"].as_array().unwrap().iter().map(|field| test::MultiRowType1::new(&field).unwrap()).collect();
        
        Ok(MultiRowType3 { id, items, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.items.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct MultiUnionIndexList {
    pub id1: i32,
    pub id2: i64,
    pub id3: String,
    pub num: i32,
    pub desc: String,
}

impl MultiUnionIndexList{
    pub(crate) fn new(json: &serde_json::Value) -> Result<MultiUnionIndexList, LubanError> {
        let id1 = (json["id1"].as_i64().unwrap() as i32);
        let id2 = json["id2"].as_i64().unwrap();
        let id3 = json["id3"].as_str().unwrap().to_string();
        let num = (json["num"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        
        Ok(MultiUnionIndexList { id1, id2, id3, num, desc, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct NotIndexList {
    pub x: i32,
    pub y: i32,
}

impl NotIndexList{
    pub(crate) fn new(json: &serde_json::Value) -> Result<NotIndexList, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        
        Ok(NotIndexList { x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct Path {
    pub id: i32,
    pub res: String,
}

impl Path{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Path, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let res = json["res"].as_str().unwrap().to_string();
        
        Ok(Path { id, res, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum RefDynamicBase {
    RefBean(std::sync::Arc<test::RefBean>),
}

impl RefDynamicBase {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "RefBean" => Ok(Self::RefBean(std::sync::Arc::new(test::RefBean::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for RefDynamicBase:{}", type_id)))
        }
    }
    
    pub fn get_x(&self) -> &i32 {
        match self {
            Self::RefBean(x) => { &x.x }
        }
    }    
        
    pub fn get_x_ref(&self) -> &Option<std::sync::Arc<test::TestBeRef>> {
        match self {
            Self::RefBean(x) => { &x.x_ref }
        }        
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::RefBean(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::RefBean as *mut test::RefBean); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct RefBean {
    pub x: i32,
    pub x_ref: Option<std::sync::Arc<test::TestBeRef>>,
    pub arr: Vec<i32>,
    pub arr_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<test::TestBeRef>>>>>,
}

impl RefBean{
    pub(crate) fn new(json: &serde_json::Value) -> Result<RefBean, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let x_ref = None;
        let arr = json["arr"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let arr_ref = None;
        
        Ok(RefBean { x, x_ref, arr, arr_ref, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x_ref = tables.TbTestBeRef.get(&self.x);
        self.arr_ref = Some(std::sync::Arc::new(self.arr.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
    }
}

#[derive(Debug)]
pub struct SepBean1 {
    pub a: i32,
    pub b: i32,
    pub c: String,
}

impl SepBean1{
    pub(crate) fn new(json: &serde_json::Value) -> Result<SepBean1, LubanError> {
        let a = (json["a"].as_i64().unwrap() as i32);
        let b = (json["b"].as_i64().unwrap() as i32);
        let c = json["c"].as_str().unwrap().to_string();
        
        Ok(SepBean1 { a, b, c, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct SepVector {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

impl SepVector{
    pub(crate) fn new(json: &serde_json::Value) -> Result<SepVector, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        let z = (json["z"].as_i64().unwrap() as i32);
        
        Ok(SepVector { x, y, z, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub enum Shape {
    Circle(std::sync::Arc<test::Circle>),
    Rectangle(std::sync::Arc<test2::Rectangle>),
}

impl Shape {
    pub(crate) fn new(json: &serde_json::Value) -> Result<Self, LubanError> {
        let type_id = json["$type"].as_str().unwrap();
        match type_id {
            "Circle" => Ok(Self::Circle(std::sync::Arc::new(test::Circle::new(json)?))),
            "test2.Rectangle" => Ok(Self::Rectangle(std::sync::Arc::new(test2::Rectangle::new(json)?))),
            _ => Err(LubanError::Bean(format!("Invalid type for Shape:{}", type_id)))
        }
    }

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        match self {
            Self::Circle(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test::Circle as *mut test::Circle); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
            Self::Rectangle(ref mut x) => { let mut b = Box::from_raw(x.as_ref() as *const test2::Rectangle as *mut test2::Rectangle); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b); }
        }
    }
}


#[derive(Debug)]
pub struct Circle {
    /// 半径
    pub radius: f32,
}

impl Circle{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Circle, LubanError> {
        let radius = (json["radius"].as_f64().unwrap() as f32);
        
        Ok(Circle { radius, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct Test3 {
    pub x: i32,
    pub y: i32,
}

impl Test3{
    pub(crate) fn new(json: &serde_json::Value) -> Result<Test3, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = (json["y"].as_i64().unwrap() as i32);
        
        Ok(Test3 { x, y, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestBeRef {
    pub id: i32,
    pub count: i32,
}

impl TestBeRef{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestBeRef, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let count = (json["count"].as_i64().unwrap() as i32);
        
        Ok(TestBeRef { id, count, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestExcelBean1 {
    /// 最高品质
    pub x1: i32,
    /// 黑色的
    pub x2: String,
    /// 蓝色的
    pub x3: i32,
    /// 最差品质
    pub x4: f32,
}

impl TestExcelBean1{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestExcelBean1, LubanError> {
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x2 = json["x2"].as_str().unwrap().to_string();
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_f64().unwrap() as f32);
        
        Ok(TestExcelBean1 { x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestExcelBean2 {
    /// 最高品质
    pub y1: i32,
    /// 黑色的
    pub y2: String,
    /// 蓝色的
    pub y3: f32,
}

impl TestExcelBean2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestExcelBean2, LubanError> {
        let y1 = (json["y1"].as_i64().unwrap() as i32);
        let y2 = json["y2"].as_str().unwrap().to_string();
        let y3 = (json["y3"].as_f64().unwrap() as f32);
        
        Ok(TestExcelBean2 { y1, y2, y3, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestFieldAlias {
    pub id: i32,
    pub name: String,
}

impl TestFieldAlias{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestFieldAlias, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        
        Ok(TestFieldAlias { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestFieldVariant {
    pub id: i32,
    pub name: String,
}

impl TestFieldVariant{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestFieldVariant, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        
        Ok(TestFieldVariant { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestFieldVariant2 {
    pub id: i32,
    pub name: String,
}

impl TestFieldVariant2{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestFieldVariant2, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let name = json["name"].as_str().unwrap().to_string();
        
        Ok(TestFieldVariant2 { id, name, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestFormat {
    pub id: i32,
    pub a1: Vec<i32>,
    pub a2: Vec<i32>,
    pub a3: Vec<i32>,
    pub a4: Vec<i32>,
    pub b1: Vec<i32>,
    pub b2: Vec<i32>,
    pub b3: Vec<i32>,
    pub b4: Vec<i32>,
    pub c1: std::collections::HashSet<i32>,
    pub c2: std::collections::HashSet<i32>,
    pub c3: std::collections::HashSet<i32>,
    pub c4: std::collections::HashSet<i32>,
    pub m1: std::collections::HashMap<i32, i32>,
    pub m2: std::collections::HashMap<i32, i32>,
    pub m3: std::collections::HashMap<i32, i32>,
    pub m4: std::collections::HashMap<i32, i32>,
    pub v31: crate::Vec3,
    pub v32: crate::Vec3,
    pub v33: crate::Vec3,
    pub v34: crate::Vec3,
    pub v41: Vec<crate::Vec3>,
    pub v42: Vec<crate::Vec3>,
    pub v43: Vec<crate::Vec3>,
    pub v44: Vec<crate::Vec3>,
}

impl TestFormat{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestFormat, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let a1 = json["a1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let a2 = json["a2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let a3 = json["a3"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let a4 = json["a4"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b1 = json["b1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b2 = json["b2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b3 = json["b3"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b4 = json["b4"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c1 = json["c1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c2 = json["c2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c3 = json["c3"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c4 = json["c4"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let m1 = std::collections::HashMap::from_iter(json["m1"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let m2 = std::collections::HashMap::from_iter(json["m2"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let m3 = std::collections::HashMap::from_iter(json["m3"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let m4 = std::collections::HashMap::from_iter(json["m4"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let v31 = vec3::new(&json["v31"])?.into();
        let v32 = vec3::new(&json["v32"])?.into();
        let v33 = vec3::new(&json["v33"])?.into();
        let v34 = vec3::new(&json["v34"])?.into();
        let v41 = json["v41"].as_array().unwrap().iter().map(|field| vec3::new(&field).unwrap().into()).collect();
        let v42 = json["v42"].as_array().unwrap().iter().map(|field| vec3::new(&field).unwrap().into()).collect();
        let v43 = json["v43"].as_array().unwrap().iter().map(|field| vec3::new(&field).unwrap().into()).collect();
        let v44 = json["v44"].as_array().unwrap().iter().map(|field| vec3::new(&field).unwrap().into()).collect();
        
        Ok(TestFormat { id, a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, m1, m2, m3, m4, v31, v32, v33, v34, v41, v42, v43, v44, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestGlobal {
    pub unlock_equip: i32,
    pub unlock_hero: i32,
}

impl TestGlobal{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestGlobal, LubanError> {
        let unlock_equip = (json["unlock_equip"].as_i64().unwrap() as i32);
        let unlock_hero = (json["unlock_hero"].as_i64().unwrap() as i32);
        
        Ok(TestGlobal { unlock_equip, unlock_hero, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestIndex {
    pub id: i32,
    pub eles: Vec<test::DemoType1>,
}

impl TestIndex{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestIndex, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let eles = json["eles"].as_array().unwrap().iter().map(|field| test::DemoType1::new(&field).unwrap()).collect();
        
        Ok(TestIndex { id, eles, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.eles.iter_mut().for_each(|mut x| { x.resolve_ref(tables); });
    }
}

#[derive(Debug)]
pub struct TestMap {
    pub id: i32,
    pub id_ref: Option<std::sync::Arc<test::TestIndex>>,
    pub x1: std::collections::HashMap<i32, i32>,
    pub x2: std::collections::HashMap<i64, i32>,
    pub x3: std::collections::HashMap<String, i32>,
    pub x4: std::collections::HashMap<test::DemoEnum, i32>,
}

impl TestMap{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestMap, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let id_ref = None;
        let x1 = std::collections::HashMap::from_iter(json["x1"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let x2 = std::collections::HashMap::from_iter(json["x2"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();(array[0].as_i64().unwrap(), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i64, i32)>>());
        let x3 = std::collections::HashMap::from_iter(json["x3"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();(array[0].as_str().unwrap().to_string(), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(String, i32)>>());
        let x4 = std::collections::HashMap::from_iter(json["x4"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();(Into::<test::DemoEnum>::into(array[0].as_i64().unwrap()), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(test::DemoEnum, i32)>>());
        
        Ok(TestMap { id, id_ref, x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.id_ref = tables.TbTestIndex.get(&self.id);
    }
}

#[derive(Debug)]
pub struct TestMapper {
    pub id: i32,
    pub audio_type: crate::CustomAudioType,
    pub v2: crate::Vec2,
}

impl TestMapper{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestMapper, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let audio_type = Into::<AudioType>::into(json["audio_type"].as_i64().unwrap()).into();
        let v2 = vec2::new(&json["v2"])?.into();
        
        Ok(TestMapper { id, audio_type, v2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestMultiColumn {
    pub id: i32,
    pub a: test::Foo,
    pub b: test::Foo,
    pub c: test::Foo,
}

impl TestMultiColumn{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestMultiColumn, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let a = test::Foo::new(&json["a"])?;
        let b = test::Foo::new(&json["b"])?;
        let c = test::Foo::new(&json["c"])?;
        
        Ok(TestMultiColumn { id, a, b, c, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.a.resolve_ref(tables);
        self.b.resolve_ref(tables);
        self.c.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct TestNull {
    pub id: i32,
    pub x1: Option<i32>,
    pub x2: Option<test::DemoEnum>,
    pub x3: Option<test::DemoType1>,
    pub x4: Option<test::DemoDynamic>,
    pub s1: Option<String>,
    pub s2: Option<String>,
}

impl TestNull{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestNull, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let mut x1 = None; if let Some(value) = json.get("x1") { x1 = Some((json["x1"].as_i64().unwrap() as i32)); }
        let mut x2 = None; if let Some(value) = json.get("x2") { x2 = Some(Into::<test::DemoEnum>::into(json["x2"].as_i64().unwrap())); }
        let mut x3 = None; if let Some(value) = json.get("x3") { x3 = Some(test::DemoType1::new(&json["x3"])?); }
        let mut x4 = None; if let Some(value) = json.get("x4") { x4 = Some(test::DemoDynamic::new(&json["x4"])?); }
        let mut s1 = None; if let Some(value) = json.get("s1") { s1 = Some(json["s1"].as_str().unwrap().to_string()); }
        let mut s2 = None; if let Some(value) = json.get("s2") { s2 = Some(json["s2"].as_str().unwrap().to_string()); }
        
        Ok(TestNull { id, x1, x2, x3, x4, s1, s2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        if let Some(x) = &mut self.x3 { x.resolve_ref(tables); }
        if let Some(x) = &mut self.x4 { x.resolve_ref(tables); }
    }
}

#[derive(Debug)]
pub struct TestRange {
    pub id: i32,
    pub f1: f32,
    pub f2: f32,
    pub d1: f64,
    pub d2: f64,
    pub i1: i32,
    pub i2: i32,
    pub i3: i32,
    pub i4: i32,
    pub l1: i64,
    pub l2: i64,
    pub l3: i64,
    pub l4: i64,
}

impl TestRange{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestRange, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let f1 = (json["f1"].as_f64().unwrap() as f32);
        let f2 = (json["f2"].as_f64().unwrap() as f32);
        let d1 = json["d1"].as_f64().unwrap();
        let d2 = json["d2"].as_f64().unwrap();
        let i1 = (json["i1"].as_i64().unwrap() as i32);
        let i2 = (json["i2"].as_i64().unwrap() as i32);
        let i3 = (json["i3"].as_i64().unwrap() as i32);
        let i4 = (json["i4"].as_i64().unwrap() as i32);
        let l1 = json["l1"].as_i64().unwrap();
        let l2 = json["l2"].as_i64().unwrap();
        let l3 = json["l3"].as_i64().unwrap();
        let l4 = json["l4"].as_i64().unwrap();
        
        Ok(TestRange { id, f1, f2, d1, d2, i1, i2, i3, i4, l1, l2, l3, l4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestRef {
    pub id: i32,
    pub x1: i32,
    pub x1_ref: Option<std::sync::Arc<test::TestBeRef>>,
    pub x1_2: i32,
    pub x1_2_ref: Option<std::sync::Arc<test::TestBeRef>>,
    pub x2: i32,
    pub x3: i32,
    pub x4: i32,
    pub x4_ref: Option<std::sync::Arc<tag::TestTag>>,
    pub a1: Vec<i32>,
    pub a1_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub a2: Vec<i32>,
    pub a2_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub b1: Vec<i32>,
    pub b1_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub b2: Vec<i32>,
    pub b2_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub c1: std::collections::HashSet<i32>,
    pub c1_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub c2: std::collections::HashSet<i32>,
    pub c2_ref: Option<std::sync::Arc<Vec<Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub d1: std::collections::HashMap<i32, i32>,
    pub d1_ref: Option<std::sync::Arc<std::collections::HashMap<i32, Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub d2: std::collections::HashMap<i32, i32>,
    pub d2_ref: Option<std::sync::Arc<std::collections::HashMap<i32, Option<std::sync::Arc<test::TestBeRef>>>>>,
    pub e1: i32,
    pub e2: i64,
    pub e3: String,
    pub f1: i32,
    pub f2: i64,
    pub f3: String,
    pub s1: test::RefDynamicBase,
}

impl TestRef{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestRef, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = (json["x1"].as_i64().unwrap() as i32);
        let x1_ref = None;
        let x1_2 = (json["x1_2"].as_i64().unwrap() as i32);
        let x1_2_ref = None;
        let x2 = (json["x2"].as_i64().unwrap() as i32);
        let x3 = (json["x3"].as_i64().unwrap() as i32);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x4_ref = None;
        let a1 = json["a1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let a1_ref = None;
        let a2 = json["a2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let a2_ref = None;
        let b1 = json["b1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b1_ref = None;
        let b2 = json["b2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let b2_ref = None;
        let c1 = json["c1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c1_ref = None;
        let c2 = json["c2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let c2_ref = None;
        let d1 = std::collections::HashMap::from_iter(json["d1"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let d1_ref = None;
        let d2 = std::collections::HashMap::from_iter(json["d2"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let d2_ref = None;
        let e1 = (json["e1"].as_i64().unwrap() as i32);
        let e2 = json["e2"].as_i64().unwrap();
        let e3 = json["e3"].as_str().unwrap().to_string();
        let f1 = (json["f1"].as_i64().unwrap() as i32);
        let f2 = json["f2"].as_i64().unwrap();
        let f3 = json["f3"].as_str().unwrap().to_string();
        let s1 = test::RefDynamicBase::new(&json["s1"])?;
        
        Ok(TestRef { id, x1, x1_ref, x1_2, x1_2_ref, x2, x3, x4, x4_ref, a1, a1_ref, a2, a2_ref, b1, b1_ref, b2, b2_ref, c1, c1_ref, c2, c2_ref, d1, d1_ref, d2, d2_ref, e1, e2, e3, f1, f2, f3, s1, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x1_ref = tables.TbTestBeRef.get(&self.x1);
        self.x1_2_ref = tables.TbTestBeRef.get(&self.x1_2);
        self.x4_ref = tables.TbTestTag.get(&self.x4);
        self.a1_ref = Some(std::sync::Arc::new(self.a1.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.a2_ref = Some(std::sync::Arc::new(self.a2.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.b1_ref = Some(std::sync::Arc::new(self.b1.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.b2_ref = Some(std::sync::Arc::new(self.b2.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        //HashSet does not support yet, not every type implement [Eq] and [Hash],use list instead.
        self.c1_ref = Some(std::sync::Arc::new(self.c1.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        //HashSet does not support yet, not every type implement [Eq] and [Hash],use list instead.
        self.c2_ref = Some(std::sync::Arc::new(self.c2.iter().map(|x| tables.TbTestBeRef.get(x)).collect()));
        self.d1_ref = Some(std::sync::Arc::new(self.d1.iter().map(|x| (x.0.clone(), tables.TbTestBeRef.get(x.1))).collect()));
        self.d2_ref = Some(std::sync::Arc::new(self.d2.iter().map(|x| (x.0.clone(), tables.TbTestBeRef.get(x.1))).collect()));
        self.s1.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct TestRow {
    pub x: i32,
    pub y: bool,
    pub z: String,
    pub a: test::Test3,
    pub b: Vec<i32>,
}

impl TestRow{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestRow, LubanError> {
        let x = (json["x"].as_i64().unwrap() as i32);
        let y = json["y"].as_bool().unwrap();
        let z = json["z"].as_str().unwrap().to_string();
        let a = test::Test3::new(&json["a"])?;
        let b = json["b"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        
        Ok(TestRow { x, y, z, a, b, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.a.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct TestScriptableObject {
    pub id: i32,
    pub desc: String,
    pub rate: f32,
    pub num: i32,
    pub v2: crate::Vec2,
    pub v3: crate::Vec3,
    pub v4: crate::Vec4,
}

impl TestScriptableObject{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestScriptableObject, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let desc = json["desc"].as_str().unwrap().to_string();
        let rate = (json["rate"].as_f64().unwrap() as f32);
        let num = (json["num"].as_i64().unwrap() as i32);
        let v2 = vec2::new(&json["v2"])?.into();
        let v3 = vec3::new(&json["v3"])?.into();
        let v4 = vec4::new(&json["v4"])?.into();
        
        Ok(TestScriptableObject { id, desc, rate, num, v2, v3, v4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestSet {
    pub id: i32,
    pub x0: String,
    pub x1: Vec<i32>,
    pub x2: Vec<i64>,
    pub x3: Vec<String>,
    pub x4: Vec<test::DemoEnum>,
}

impl TestSet{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestSet, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x0 = json["x0"].as_str().unwrap().to_string();
        let x1 = json["x1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x2 = json["x2"].as_array().unwrap().iter().map(|field| field.as_i64().unwrap()).collect();
        let x3 = json["x3"].as_array().unwrap().iter().map(|field| field.as_str().unwrap().to_string()).collect();
        let x4 = json["x4"].as_array().unwrap().iter().map(|field| Into::<test::DemoEnum>::into(field.as_i64().unwrap())).collect();
        
        Ok(TestSet { id, x0, x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestSize {
    pub id: i32,
    pub x1: Vec<i32>,
    pub x2: Vec<i32>,
    pub x3: std::collections::HashSet<i32>,
    pub x4: std::collections::HashMap<i32, i32>,
}

impl TestSize{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestSize, LubanError> {
        let id = (json["id"].as_i64().unwrap() as i32);
        let x1 = json["x1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x2 = json["x2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x3 = json["x3"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let x4 = std::collections::HashMap::from_iter(json["x4"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        
        Ok(TestSize { id, x1, x2, x3, x4, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
    }
}

#[derive(Debug)]
pub struct TestString {
    pub id: String,
    pub s1: String,
    pub s2: String,
    pub cs1: test::CompactString,
    pub cs2: test::CompactString,
    pub css: Vec<String>,
    pub css2: Vec<String>,
}

impl TestString{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestString, LubanError> {
        let id = json["id"].as_str().unwrap().to_string();
        let s1 = json["s1"].as_str().unwrap().to_string();
        let s2 = json["s2"].as_str().unwrap().to_string();
        let cs1 = test::CompactString::new(&json["cs1"])?;
        let cs2 = test::CompactString::new(&json["cs2"])?;
        let css = json["css"].as_array().unwrap().iter().map(|field| field.as_str().unwrap().to_string()).collect();
        let css2 = json["css2"].as_array().unwrap().iter().map(|field| field.as_str().unwrap().to_string()).collect();
        
        Ok(TestString { id, s1, s2, cs1, cs2, css, css2, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.cs1.resolve_ref(tables);
        self.cs2.resolve_ref(tables);
    }
}

#[derive(Debug)]
pub struct TestUeType {
    pub x1: bool,
    pub x2: u8,
    pub x3: i16,
    pub x4: i32,
    pub x5: i64,
    pub x6: f32,
    pub x10: String,
    pub x12: test::DemoType1,
    pub x13: test::ETestUeType,
    pub t1: u64,
    pub k1: Vec<i32>,
    pub k2: Vec<i32>,
    pub k5: std::collections::HashSet<i32>,
    pub k8: std::collections::HashMap<i32, i32>,
    pub k9: Vec<test::DemoE2>,
}

impl TestUeType{
    pub(crate) fn new(json: &serde_json::Value) -> Result<TestUeType, LubanError> {
        let x1 = json["x1"].as_bool().unwrap();
        let x2 = (json["x2"].as_u64().unwrap() as u8);
        let x3 = (json["x3"].as_i64().unwrap() as i16);
        let x4 = (json["x4"].as_i64().unwrap() as i32);
        let x5 = json["x5"].as_i64().unwrap();
        let x6 = (json["x6"].as_f64().unwrap() as f32);
        let x10 = json["x10"].as_str().unwrap().to_string();
        let x12 = test::DemoType1::new(&json["x12"])?;
        let x13 = Into::<test::ETestUeType>::into(json["x13"].as_i64().unwrap());
        let t1 = (json["t1"].as_i64().unwrap() as u64);
        let k1 = json["k1"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k2 = json["k2"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k5 = json["k5"].as_array().unwrap().iter().map(|field| (field.as_i64().unwrap() as i32)).collect();
        let k8 = std::collections::HashMap::from_iter(json["k8"].as_array().unwrap().iter().map(|x| {let array = x.as_array().unwrap();((array[0].as_i64().unwrap() as i32), (array[1].as_i64().unwrap() as i32))}).collect::<Vec<(i32, i32)>>());
        let k9 = json["k9"].as_array().unwrap().iter().map(|field| test::DemoE2::new(&field).unwrap()).collect();
        
        Ok(TestUeType { x1, x2, x3, x4, x5, x6, x10, x12, x13, t1, k1, k2, k5, k8, k9, })
    }    

    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.x12.resolve_ref(tables);
    }
}


#[derive(Debug)]
pub struct TbFullTypes {
    pub data_list: Vec<std::sync::Arc<test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoType2>>,
}

impl TbFullTypes {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbFullTypes>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DemoType2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DemoType2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbFullTypes { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DemoType2 as *mut test::DemoType2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbFullTypes {
    type Output = std::sync::Arc<test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbSingleton {
    pub data: test::DemoSingletonType,
}

impl TbSingleton {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbSingleton>, LubanError> {
        let json = json.as_array().unwrap();
        let n = json.len();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = test::DemoSingletonType::new(&json[0])?;
        Ok(std::sync::Arc::new(TbSingleton { data }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }
}


#[derive(Debug)]
pub struct TbNotIndexList {
    pub data_list: Vec<std::sync::Arc<test::NotIndexList>>,
}

impl TbNotIndexList {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbNotIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<test::NotIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::NotIndexList::new(&x)?);
            data_list.push(row.clone());
        }

    Ok(std::sync::Arc::new(TbNotIndexList { 
            data_list,
        }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::NotIndexList as *mut test::NotIndexList); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}


#[derive(Debug)]
pub struct TbMultiUnionIndexList {
    pub data_list: Vec<std::sync::Arc<test::MultiUnionIndexList>>,
    pub data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<test::MultiUnionIndexList>>,
}

impl TbMultiUnionIndexList {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiUnionIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<test::MultiUnionIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::MultiUnionIndexList::new(&x)?);
            data_list.push(row.clone());
        }
        let mut data_map_union: std::collections::HashMap<(i32, i64, String), std::sync::Arc<test::MultiUnionIndexList>> = Default::default();
        for x in &data_list {
            data_map_union.insert((x.id1, x.id2, x.id3.clone()), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiUnionIndexList { 
            data_list,
            data_map_union,
        }))
    }
    
    pub fn get(&self, key: &(i32, i64, String)) -> Option<std::sync::Arc<test::MultiUnionIndexList>> {
        self.data_map_union.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::MultiUnionIndexList as *mut test::MultiUnionIndexList); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}


#[derive(Debug)]
pub struct TbMultiIndexList {
    pub data_list: Vec<std::sync::Arc<test::MultiIndexList>>,
    pub data_map_id1: std::collections::HashMap<i32, std::sync::Arc<test::MultiIndexList>>,
    pub data_map_id2: std::collections::HashMap<i64, std::sync::Arc<test::MultiIndexList>>,
    pub data_map_id3: std::collections::HashMap<String, std::sync::Arc<test::MultiIndexList>>,
}

impl TbMultiIndexList {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiIndexList>, LubanError> {
        let mut data_list: Vec<std::sync::Arc<test::MultiIndexList>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::MultiIndexList::new(&x)?);
            data_list.push(row.clone());
        }
        let mut data_map_id1: std::collections::HashMap<i32, std::sync::Arc<test::MultiIndexList>> = Default::default();
        let mut data_map_id2: std::collections::HashMap<i64, std::sync::Arc<test::MultiIndexList>> = Default::default();
        let mut data_map_id3: std::collections::HashMap<String, std::sync::Arc<test::MultiIndexList>> = Default::default();
        for x in &data_list {
            data_map_id1.insert(x.id1.clone(), x.clone());
            data_map_id2.insert(x.id2.clone(), x.clone());
            data_map_id3.insert(x.id3.clone(), x.clone());
        }

    Ok(std::sync::Arc::new(TbMultiIndexList { 
            data_list,
            data_map_id1,
            data_map_id2,
            data_map_id3,
        }))
    }
    pub fn get_by_id1(&self, key: &i32) -> Option<std::sync::Arc<test::MultiIndexList>> {
        self.data_map_id1.get(key).map(|x| x.clone())
    }
    pub fn get_by_id2(&self, key: &i64) -> Option<std::sync::Arc<test::MultiIndexList>> {
        self.data_map_id2.get(key).map(|x| x.clone())
    }
    pub fn get_by_id3(&self, key: &String) -> Option<std::sync::Arc<test::MultiIndexList>> {
        self.data_map_id3.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::MultiIndexList as *mut test::MultiIndexList); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}


#[derive(Debug)]
pub struct TbDataFromMisc {
    pub data_list: Vec<std::sync::Arc<test::DemoType2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoType2>>,
}

impl TbDataFromMisc {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDataFromMisc>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoType2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DemoType2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DemoType2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDataFromMisc { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DemoType2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DemoType2 as *mut test::DemoType2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDataFromMisc {
    type Output = std::sync::Arc<test::DemoType2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowRecord {
    pub data_list: Vec<std::sync::Arc<test::MultiRowRecord>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::MultiRowRecord>>,
}

impl TbMultiRowRecord {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiRowRecord>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::MultiRowRecord>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::MultiRowRecord>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::MultiRowRecord::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowRecord { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::MultiRowRecord>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::MultiRowRecord as *mut test::MultiRowRecord); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbMultiRowRecord {
    type Output = std::sync::Arc<test::MultiRowRecord>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMultiColumn {
    pub data_list: Vec<std::sync::Arc<test::TestMultiColumn>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestMultiColumn>>,
}

impl TbTestMultiColumn {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestMultiColumn>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestMultiColumn>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestMultiColumn>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestMultiColumn::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMultiColumn { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestMultiColumn>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestMultiColumn as *mut test::TestMultiColumn); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestMultiColumn {
    type Output = std::sync::Arc<test::TestMultiColumn>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbMultiRowTitle {
    pub data_list: Vec<std::sync::Arc<test::MultiRowTitle>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::MultiRowTitle>>,
}

impl TbMultiRowTitle {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbMultiRowTitle>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::MultiRowTitle>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::MultiRowTitle>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::MultiRowTitle::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbMultiRowTitle { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::MultiRowTitle>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::MultiRowTitle as *mut test::MultiRowTitle); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbMultiRowTitle {
    type Output = std::sync::Arc<test::MultiRowTitle>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestNull {
    pub data_list: Vec<std::sync::Arc<test::TestNull>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestNull>>,
}

impl TbTestNull {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestNull>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestNull>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestNull>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestNull::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestNull { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestNull>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestNull as *mut test::TestNull); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestNull {
    type Output = std::sync::Arc<test::TestNull>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoPrimitive {
    pub data_list: Vec<std::sync::Arc<test::DemoPrimitiveTypesTable>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoPrimitiveTypesTable>>,
}

impl TbDemoPrimitive {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoPrimitive>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoPrimitiveTypesTable>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DemoPrimitiveTypesTable>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DemoPrimitiveTypesTable::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoPrimitive { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DemoPrimitiveTypesTable>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DemoPrimitiveTypesTable as *mut test::DemoPrimitiveTypesTable); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoPrimitive {
    type Output = std::sync::Arc<test::DemoPrimitiveTypesTable>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestString {
    pub data_list: Vec<std::sync::Arc<test::TestString>>,
    pub data_map: std::collections::HashMap<String, std::sync::Arc<test::TestString>>,
}

impl TbTestString {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestString>, LubanError> {
        let mut data_map: std::collections::HashMap<String, std::sync::Arc<test::TestString>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestString>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestString::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestString { data_map, data_list }))
    }

    pub fn get(&self, key: &String) -> Option<std::sync::Arc<test::TestString>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestString as *mut test::TestString); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<String> for TbTestString {
    type Output = std::sync::Arc<test::TestString>;

    fn index(&self, index: String) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup {
    pub data_list: Vec<std::sync::Arc<test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>>,
}

impl TbDemoGroup {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DemoGroup as *mut test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup {
    type Output = std::sync::Arc<test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_C {
    pub data_list: Vec<std::sync::Arc<test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>>,
}

impl TbDemoGroup_C {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup_C>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_C { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DemoGroup as *mut test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup_C {
    type Output = std::sync::Arc<test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_S {
    pub data_list: Vec<std::sync::Arc<test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>>,
}

impl TbDemoGroup_S {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup_S>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_S { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DemoGroup as *mut test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup_S {
    type Output = std::sync::Arc<test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDemoGroup_E {
    pub data_list: Vec<std::sync::Arc<test::DemoGroup>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>>,
}

impl TbDemoGroup_E {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDemoGroup_E>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DemoGroup>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DemoGroup>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DemoGroup::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDemoGroup_E { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DemoGroup>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DemoGroup as *mut test::DemoGroup); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDemoGroup_E {
    type Output = std::sync::Arc<test::DemoGroup>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestGlobal {
    pub data: test::TestGlobal,
}

impl TbTestGlobal {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestGlobal>, LubanError> {
        let json = json.as_array().unwrap();
        let n = json.len();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = test::TestGlobal::new(&json[0])?;
        Ok(std::sync::Arc::new(TbTestGlobal { data }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }
}


#[derive(Debug)]
pub struct TbTestBeRef {
    pub data_list: Vec<std::sync::Arc<test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestBeRef>>,
}

impl TbTestBeRef {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestBeRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestBeRef>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestBeRef::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestBeRef as *mut test::TestBeRef); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestBeRef {
    type Output = std::sync::Arc<test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestBeRef2 {
    pub data_list: Vec<std::sync::Arc<test::TestBeRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestBeRef>>,
}

impl TbTestBeRef2 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestBeRef2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestBeRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestBeRef>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestBeRef::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestBeRef2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestBeRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestBeRef as *mut test::TestBeRef); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestBeRef2 {
    type Output = std::sync::Arc<test::TestBeRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestRef {
    pub data_list: Vec<std::sync::Arc<test::TestRef>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestRef>>,
}

impl TbTestRef {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestRef>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestRef>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestRef>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestRef::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestRef { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestRef>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestRef as *mut test::TestRef); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestRef {
    type Output = std::sync::Arc<test::TestRef>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSize {
    pub data_list: Vec<std::sync::Arc<test::TestSize>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestSize>>,
}

impl TbTestSize {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestSize>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestSize>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestSize>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestSize::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSize { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestSize>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestSize as *mut test::TestSize); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestSize {
    type Output = std::sync::Arc<test::TestSize>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestSet {
    pub data_list: Vec<std::sync::Arc<test::TestSet>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestSet>>,
}

impl TbTestSet {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestSet>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestSet>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestSet>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestSet::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestSet { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestSet>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestSet as *mut test::TestSet); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestSet {
    type Output = std::sync::Arc<test::TestSet>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestRange {
    pub data_list: Vec<std::sync::Arc<test::TestRange>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestRange>>,
}

impl TbTestRange {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestRange>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestRange>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestRange>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestRange::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestRange { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestRange>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestRange as *mut test::TestRange); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestRange {
    type Output = std::sync::Arc<test::TestRange>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDetectCsvEncoding {
    pub data_list: Vec<std::sync::Arc<test::DetectEncoding>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DetectEncoding>>,
}

impl TbDetectCsvEncoding {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDetectCsvEncoding>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DetectEncoding>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DetectEncoding>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DetectEncoding::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDetectCsvEncoding { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DetectEncoding>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DetectEncoding as *mut test::DetectEncoding); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDetectCsvEncoding {
    type Output = std::sync::Arc<test::DetectEncoding>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbItem2 {
    pub data_list: Vec<std::sync::Arc<test::ItemBase>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::ItemBase>>,
}

impl TbItem2 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbItem2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::ItemBase>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::ItemBase>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::ItemBase::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.get_id().clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbItem2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::ItemBase>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::ItemBase as *mut test::ItemBase); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbItem2 {
    type Output = std::sync::Arc<test::ItemBase>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestIndex {
    pub data_list: Vec<std::sync::Arc<test::TestIndex>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestIndex>>,
}

impl TbTestIndex {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestIndex>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestIndex>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestIndex>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestIndex::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestIndex { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestIndex>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestIndex as *mut test::TestIndex); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestIndex {
    type Output = std::sync::Arc<test::TestIndex>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMap {
    pub data_list: Vec<std::sync::Arc<test::TestMap>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestMap>>,
}

impl TbTestMap {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestMap>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestMap>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestMap>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestMap::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMap { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestMap>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestMap as *mut test::TestMap); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestMap {
    type Output = std::sync::Arc<test::TestMap>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbExcelFromJson {
    pub data_list: Vec<std::sync::Arc<test::ExcelFromJson>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::ExcelFromJson>>,
}

impl TbExcelFromJson {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbExcelFromJson>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::ExcelFromJson>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::ExcelFromJson>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::ExcelFromJson::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.x4.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJson { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::ExcelFromJson>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::ExcelFromJson as *mut test::ExcelFromJson); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbExcelFromJson {
    type Output = std::sync::Arc<test::ExcelFromJson>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable1 {
    pub data_list: Vec<std::sync::Arc<test::CompositeJsonTable1>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::CompositeJsonTable1>>,
}

impl TbCompositeJsonTable1 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbCompositeJsonTable1>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::CompositeJsonTable1>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::CompositeJsonTable1>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::CompositeJsonTable1::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable1 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::CompositeJsonTable1>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::CompositeJsonTable1 as *mut test::CompositeJsonTable1); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable1 {
    type Output = std::sync::Arc<test::CompositeJsonTable1>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable2 {
    pub data_list: Vec<std::sync::Arc<test::CompositeJsonTable2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::CompositeJsonTable2>>,
}

impl TbCompositeJsonTable2 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbCompositeJsonTable2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::CompositeJsonTable2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::CompositeJsonTable2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::CompositeJsonTable2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbCompositeJsonTable2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::CompositeJsonTable2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::CompositeJsonTable2 as *mut test::CompositeJsonTable2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbCompositeJsonTable2 {
    type Output = std::sync::Arc<test::CompositeJsonTable2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbCompositeJsonTable3 {
    pub data: test::CompositeJsonTable3,
}

impl TbCompositeJsonTable3 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbCompositeJsonTable3>, LubanError> {
        let json = json.as_array().unwrap();
        let n = json.len();
        if n != 1 { return Err(LubanError::Table(format!("table mode=one, but size != 1"))); }
        let data = test::CompositeJsonTable3::new(&json[0])?;
        Ok(std::sync::Arc::new(TbCompositeJsonTable3 { data }))
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data.resolve_ref(tables);
    }
}


#[derive(Debug)]
pub struct TbExcelFromJsonMultiRow {
    pub data_list: Vec<std::sync::Arc<test::ExcelFromJsonMultiRow>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::ExcelFromJsonMultiRow>>,
}

impl TbExcelFromJsonMultiRow {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbExcelFromJsonMultiRow>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::ExcelFromJsonMultiRow>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::ExcelFromJsonMultiRow>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::ExcelFromJsonMultiRow::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbExcelFromJsonMultiRow { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::ExcelFromJsonMultiRow>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::ExcelFromJsonMultiRow as *mut test::ExcelFromJsonMultiRow); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbExcelFromJsonMultiRow {
    type Output = std::sync::Arc<test::ExcelFromJsonMultiRow>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestScriptableObject {
    pub data_list: Vec<std::sync::Arc<test::TestScriptableObject>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestScriptableObject>>,
}

impl TbTestScriptableObject {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestScriptableObject>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestScriptableObject>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestScriptableObject>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestScriptableObject::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestScriptableObject { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestScriptableObject>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestScriptableObject as *mut test::TestScriptableObject); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestScriptableObject {
    type Output = std::sync::Arc<test::TestScriptableObject>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbPath {
    pub data_list: Vec<std::sync::Arc<test::Path>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::Path>>,
}

impl TbPath {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbPath>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::Path>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::Path>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::Path::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbPath { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::Path>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::Path as *mut test::Path); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbPath {
    type Output = std::sync::Arc<test::Path>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFieldAlias {
    pub data_list: Vec<std::sync::Arc<test::TestFieldAlias>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFieldAlias>>,
}

impl TbTestFieldAlias {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestFieldAlias>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFieldAlias>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestFieldAlias>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestFieldAlias::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFieldAlias { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestFieldAlias>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestFieldAlias as *mut test::TestFieldAlias); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFieldAlias {
    type Output = std::sync::Arc<test::TestFieldAlias>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFieldVariant {
    pub data_list: Vec<std::sync::Arc<test::TestFieldVariant>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFieldVariant>>,
}

impl TbTestFieldVariant {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestFieldVariant>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFieldVariant>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestFieldVariant>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestFieldVariant::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFieldVariant { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestFieldVariant>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestFieldVariant as *mut test::TestFieldVariant); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFieldVariant {
    type Output = std::sync::Arc<test::TestFieldVariant>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFieldVariant2 {
    pub data_list: Vec<std::sync::Arc<test::TestFieldVariant2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFieldVariant2>>,
}

impl TbTestFieldVariant2 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestFieldVariant2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFieldVariant2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestFieldVariant2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestFieldVariant2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFieldVariant2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestFieldVariant2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestFieldVariant2 as *mut test::TestFieldVariant2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFieldVariant2 {
    type Output = std::sync::Arc<test::TestFieldVariant2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestMapper {
    pub data_list: Vec<std::sync::Arc<test::TestMapper>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestMapper>>,
}

impl TbTestMapper {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestMapper>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestMapper>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestMapper>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestMapper::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestMapper { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestMapper>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestMapper as *mut test::TestMapper); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestMapper {
    type Output = std::sync::Arc<test::TestMapper>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbDefineFromExcel2 {
    pub data_list: Vec<std::sync::Arc<test::DefineFromExcel2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::DefineFromExcel2>>,
}

impl TbDefineFromExcel2 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbDefineFromExcel2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::DefineFromExcel2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::DefineFromExcel2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::DefineFromExcel2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbDefineFromExcel2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::DefineFromExcel2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::DefineFromExcel2 as *mut test::DefineFromExcel2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbDefineFromExcel2 {
    type Output = std::sync::Arc<test::DefineFromExcel2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbAutoImport2 {
    pub data_list: Vec<std::sync::Arc<test::AutoImport2>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::AutoImport2>>,
}

impl TbAutoImport2 {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbAutoImport2>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::AutoImport2>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::AutoImport2>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::AutoImport2::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbAutoImport2 { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::AutoImport2>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::AutoImport2 as *mut test::AutoImport2); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbAutoImport2 {
    type Output = std::sync::Arc<test::AutoImport2>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


#[derive(Debug)]
pub struct TbTestFormat {
    pub data_list: Vec<std::sync::Arc<test::TestFormat>>,
    pub data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFormat>>,
}

impl TbTestFormat {
    pub(crate) fn new(json: &serde_json::Value) -> Result<std::sync::Arc<TbTestFormat>, LubanError> {
        let mut data_map: std::collections::HashMap<i32, std::sync::Arc<test::TestFormat>> = Default::default();
        let mut data_list: Vec<std::sync::Arc<test::TestFormat>> = vec![];

        for x in json.as_array().unwrap() {
            let row = std::sync::Arc::new(test::TestFormat::new(&x)?);
            data_list.push(row.clone());
            data_map.insert(row.id.clone(), row.clone());
        }

        Ok(std::sync::Arc::new(TbTestFormat { data_map, data_list }))
    }

    pub fn get(&self, key: &i32) -> Option<std::sync::Arc<test::TestFormat>> {
        self.data_map.get(key).map(|x| x.clone())
    }
    
    pub(crate) unsafe fn resolve_ref(&mut self, tables: &Tables) {
        self.data_list.iter_mut().for_each(|mut x| {
           let mut b = Box::from_raw(x.as_ref() as *const test::TestFormat as *mut test::TestFormat); b.as_mut().resolve_ref(tables); let _ = Box::into_raw(b);
        });
    }
}

impl std::ops::Index<i32> for TbTestFormat {
    type Output = std::sync::Arc<test::TestFormat>;

    fn index(&self, index: i32) -> &Self::Output {
        &self.data_map.get(&index).unwrap()
    }
}


